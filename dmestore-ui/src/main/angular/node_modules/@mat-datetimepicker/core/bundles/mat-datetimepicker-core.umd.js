(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/material/core'), require('@angular/cdk/a11y'), require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/material/button'), require('@angular/material/dialog'), require('@angular/material/icon'), require('@angular/cdk/keycodes'), require('@angular/material/datepicker'), require('rxjs/operators'), require('@angular/animations'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/cdk/portal'), require('rxjs'), require('@angular/forms'), require('@angular/material/input'), require('@angular/material/form-field')) :
    typeof define === 'function' && define.amd ? define('@mat-datetimepicker/core', ['exports', '@angular/core', '@angular/material/core', '@angular/cdk/a11y', '@angular/cdk/overlay', '@angular/common', '@angular/material/button', '@angular/material/dialog', '@angular/material/icon', '@angular/cdk/keycodes', '@angular/material/datepicker', 'rxjs/operators', '@angular/animations', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/cdk/portal', 'rxjs', '@angular/forms', '@angular/material/input', '@angular/material/form-field'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['mat-datetimepicker'] = global['mat-datetimepicker'] || {}, global['mat-datetimepicker'].core = {}), global.ng.core, global.ng.material.core, global.ng.cdk.a11y, global.ng.cdk.overlay, global.ng.common, global.ng.material.button, global.ng.material.dialog, global.ng.material.icon, global.ng.cdk.keycodes, global.ng.material.datepicker, global.rxjs.operators, global.ng.animations, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.cdk.portal, global.rxjs, global.ng.forms, global.ng.material.input, global.ng.material.formField));
}(this, (function (exports, core, core$1, a11y, overlay, common, button, dialog, icon, keycodes, datepicker, operators, animations, bidi, coercion, portal, rxjs, forms, input, formField) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @abstract
     * @template D
     */
    var DatetimeAdapter = /** @class */ (function (_super) {
        __extends(DatetimeAdapter, _super);
        /**
         * @param {?} _delegate
         */
        function DatetimeAdapter(_delegate) {
            var _this = _super.call(this) || this;
            _this._delegate = _delegate;
            return _this;
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        DatetimeAdapter.prototype.getValidDateOrNull = function (obj) {
            return (this.isDateInstance(obj) && this.isValid(obj)) ? obj : null;
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.compareDatetime = function (first, second) {
            return this.compareDate(first, second) ||
                this.getHour(first) - this.getHour(second) ||
                this.getMinute(first) - this.getMinute(second);
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameDatetime = function (first, second) {
            if (first && second) {
                /** @type {?} */
                var firstValid = this.isValid(first);
                /** @type {?} */
                var secondValid = this.isValid(second);
                if (firstValid && secondValid) {
                    return !this.compareDatetime(first, second);
                }
                return firstValid === secondValid;
            }
            return first === second;
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameYear = function (first, second) {
            return first && second && this.getYear(first) === this.getYear(second);
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameDay = function (first, second) {
            return first && second && this.getDate(first) === this.getDate(second) && this.sameMonthAndYear(first, second);
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameHour = function (first, second) {
            return first && second && this.getHour(first) === this.getHour(second) && this.sameDay(first, second);
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameMinute = function (first, second) {
            return first && second && this.getMinute(first) === this.getMinute(second) && this.sameHour(first, second);
        };
        /**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        DatetimeAdapter.prototype.sameMonthAndYear = function (first, second) {
            if (first && second) {
                /** @type {?} */
                var firstValid = this.isValid(first);
                /** @type {?} */
                var secondValid = this.isValid(second);
                if (firstValid && secondValid) {
                    return !(this.getYear(first) - this.getYear(second) ||
                        this.getMonth(first) - this.getMonth(second));
                }
                return firstValid === secondValid;
            }
            return first === second;
        };
        // delegate
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.clone = function (date) {
            return this._delegate.clone(date);
        };
        /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
        DatetimeAdapter.prototype.addCalendarYears = function (date, years) {
            return this._delegate.addCalendarYears(date, years);
        };
        /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        DatetimeAdapter.prototype.addCalendarMonths = function (date, months) {
            return this._delegate.addCalendarMonths(date, months);
        };
        /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
        DatetimeAdapter.prototype.addCalendarDays = function (date, days) {
            return this._delegate.addCalendarDays(date, days);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getYear = function (date) {
            return this._delegate.getYear(date);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getMonth = function (date) {
            return this._delegate.getMonth(date);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getDate = function (date) {
            return this._delegate.getDate(date);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getDayOfWeek = function (date) {
            return this._delegate.getDayOfWeek(date);
        };
        /**
         * @param {?} style
         * @return {?}
         */
        DatetimeAdapter.prototype.getMonthNames = function (style) {
            return this._delegate.getMonthNames(style);
        };
        /**
         * @return {?}
         */
        DatetimeAdapter.prototype.getDateNames = function () {
            return this._delegate.getDateNames();
        };
        /**
         * @param {?} style
         * @return {?}
         */
        DatetimeAdapter.prototype.getDayOfWeekNames = function (style) {
            return this._delegate.getDayOfWeekNames(style);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getYearName = function (date) {
            return this._delegate.getYearName(date);
        };
        /**
         * @return {?}
         */
        DatetimeAdapter.prototype.getFirstDayOfWeek = function () {
            return this._delegate.getFirstDayOfWeek();
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getNumDaysInMonth = function (date) {
            return this._delegate.getNumDaysInMonth(date);
        };
        /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.createDate = function (year, month, date) {
            return this._delegate.createDate(year, month, date);
        };
        /**
         * @return {?}
         */
        DatetimeAdapter.prototype.today = function () {
            return this._delegate.today();
        };
        /**
         * @param {?} value
         * @param {?} parseFormat
         * @return {?}
         */
        DatetimeAdapter.prototype.parse = function (value, parseFormat) {
            return this._delegate.parse(value, parseFormat);
        };
        /**
         * @param {?} date
         * @param {?} displayFormat
         * @return {?}
         */
        DatetimeAdapter.prototype.format = function (date, displayFormat) {
            return this._delegate.format(date, displayFormat);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.toIso8601 = function (date) {
            return this._delegate.toIso8601(date);
        };
        /**
         * @param {?} obj
         * @return {?}
         */
        DatetimeAdapter.prototype.isDateInstance = function (obj) {
            return this._delegate.isDateInstance(obj);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.isValid = function (date) {
            return this._delegate.isValid(date);
        };
        /**
         * @return {?}
         */
        DatetimeAdapter.prototype.invalid = function () {
            return this._delegate.invalid();
        };
        /**
         * @param {?} date
         * @param {?=} min
         * @param {?=} max
         * @return {?}
         */
        DatetimeAdapter.prototype.clampDate = function (date, min, max) {
            if (min && this.compareDatetime(date, min) < 0) {
                return min;
            }
            if (max && this.compareDatetime(date, max) > 0) {
                return max;
            }
            return date;
        };
        return DatetimeAdapter;
    }(core$1.DateAdapter));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        DatetimeAdapter.prototype._delegate;
        /**
         * @abstract
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getHour = function (date) { };
        /**
         * @abstract
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getMinute = function (date) { };
        /**
         * @abstract
         * @param {?} date
         * @return {?}
         */
        DatetimeAdapter.prototype.getFirstDateOfMonth = function (date) { };
        /**
         * @abstract
         * @param {?} startDate
         * @param {?} endDate
         * @return {?}
         */
        DatetimeAdapter.prototype.isInNextMonth = function (startDate, endDate) { };
        /**
         * @abstract
         * @return {?}
         */
        DatetimeAdapter.prototype.getHourNames = function () { };
        /**
         * @abstract
         * @return {?}
         */
        DatetimeAdapter.prototype.getMinuteNames = function () { };
        /**
         * @abstract
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        DatetimeAdapter.prototype.addCalendarHours = function (date, months) { };
        /**
         * @abstract
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        DatetimeAdapter.prototype.addCalendarMinutes = function (date, months) { };
        /**
         * @abstract
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @param {?} hour
         * @param {?} minute
         * @return {?}
         */
        DatetimeAdapter.prototype.createDatetime = function (year, month, date, hour, minute) { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: adapter/datetime-formats.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function MatDatetimeFormats() { }
    if (false) {
        /** @type {?} */
        MatDatetimeFormats.prototype.parse;
        /** @type {?} */
        MatDatetimeFormats.prototype.display;
    }
    /** @type {?} */
    var MAT_DATETIME_FORMATS = new core.InjectionToken("mat-datetime-formats");

    var ɵ0 = /**
     * @param {?} i
     * @return {?}
     */ function (/**
     * @param {?} i
     * @return {?}
     */ i) { return String(i); };
    /**
     * The default hour names to use if Intl API is not available.
     * @type {?}
     */
    var DEFAULT_HOUR_NAMES = range(24, (ɵ0));
    var ɵ1 = /**
     * @param {?} i
     * @return {?}
     */ function (/**
     * @param {?} i
     * @return {?}
     */ i) { return String(i); };
    /**
     * The default minute names to use if Intl API is not available.
     * @type {?}
     */
    var DEFAULT_MINUTE_NAMES = range(60, (ɵ1));
    /**
     * @template T
     * @param {?} length
     * @param {?} valueFunction
     * @return {?}
     */
    function range(length, valueFunction) {
        /** @type {?} */
        var valuesArray = Array(length);
        for (var i = 0; i < length; i++) {
            valuesArray[i] = valueFunction(i);
        }
        return valuesArray;
    }
    var NativeDatetimeAdapter = /** @class */ (function (_super) {
        __extends(NativeDatetimeAdapter, _super);
        /**
         * @param {?} matDateLocale
         * @param {?} _delegate
         */
        function NativeDatetimeAdapter(matDateLocale, _delegate) {
            var _this = _super.call(this, _delegate) || this;
            _this.setLocale(matDateLocale);
            return _this;
        }
        /**
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.clone = function (date) {
            return this.createDatetime(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date), this.getMinute(date));
        };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getHour = function (date) {
            return date.getHours();
        };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getMinute = function (date) {
            return date.getMinutes();
        };
        /**
         * @param {?} startDate
         * @param {?} endDate
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.isInNextMonth = function (startDate, endDate) {
            /** @type {?} */
            var nextMonth = this.getDateInNextMonth(startDate);
            return this.sameMonthAndYear(nextMonth, endDate);
        };
        /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @param {?} hour
         * @param {?} minute
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.createDatetime = function (year, month, date, hour, minute) {
            // Check for invalid month and date (except upper bound on date which we have to check after
            // creating the Date).
            if (month < 0 || month > 11) {
                throw Error("Invalid month index \"" + month + "\". Month index has to be between 0 and 11.");
            }
            if (date < 1) {
                throw Error("Invalid date \"" + date + "\". Date has to be greater than 0.");
            }
            if (hour < 0 || hour > 23) {
                throw Error("Invalid hour \"" + hour + "\". Hour has to be between 0 and 23.");
            }
            if (minute < 0 || minute > 59) {
                throw Error("Invalid minute \"" + minute + "\". Minute has to be between 0 and 59.");
            }
            /** @type {?} */
            var result = this._createDateWithOverflow(year, month, date, hour, minute);
            // Check that the date wasn't above the upper bound for the month, causing the month to overflow
            if (result.getMonth() !== month) {
                throw Error("Invalid date \"" + date + "\" for month with index \"" + month + "\".");
            }
            return result;
        };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getFirstDateOfMonth = function (date) {
            /** @type {?} */
            var result = new Date();
            result.setFullYear(date.getFullYear(), date.getMonth(), 1);
            return result;
        };
        /**
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getHourNames = function () {
            return DEFAULT_HOUR_NAMES;
        };
        /**
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getMinuteNames = function () {
            return DEFAULT_MINUTE_NAMES;
        };
        /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.addCalendarYears = function (date, years) {
            return this.addCalendarMonths(date, years * 12);
        };
        /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.addCalendarMonths = function (date, months) {
            /** @type {?} */
            var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date), this.getHour(date), this.getMinute(date));
            // It's possible to wind up in the wrong month if the original month has more days than the new
            // month. In this case we want to go to the last day of the desired month.
            // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
            // guarantee this.
            if (this.getMonth(newDate) !== ((this.getMonth(date) + months) % 12 + 12) % 12) {
                newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0, this.getHour(date), this.getMinute(date));
            }
            return newDate;
        };
        /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.addCalendarDays = function (date, days) {
            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days, this.getHour(date), this.getMinute(date));
        };
        /**
         * @param {?} date
         * @param {?} hours
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.addCalendarHours = function (date, hours) {
            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date) + hours, this.getMinute(date));
        };
        /**
         * @param {?} date
         * @param {?} minutes
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.addCalendarMinutes = function (date, minutes) {
            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHour(date), this.getMinute(date) + minutes);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.toIso8601 = function (date) {
            return _super.prototype.toIso8601.call(this, date) + "T" + [
                this._2digit(date.getUTCHours()),
                this._2digit(date.getUTCMinutes())
            ].join(":");
        };
        /**
         * @private
         * @param {?} date
         * @return {?}
         */
        NativeDatetimeAdapter.prototype.getDateInNextMonth = function (date) {
            return new Date(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes());
        };
        /**
         * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
         * other browsers do not. We remove them to make output consistent and because they interfere with
         * date parsing.
         * @private
         * @param {?} str The string to strip direction characters from.
         * @return {?} The stripped string.
         */
        NativeDatetimeAdapter.prototype._stripDirectionalityCharacters = function (str) {
            return str.replace(/[\u200e\u200f]/g, "");
        };
        /**
         * Pads a number to make it two digits.
         * @private
         * @param {?} n The number to pad.
         * @return {?} The padded number.
         */
        NativeDatetimeAdapter.prototype._2digit = function (n) {
            return ("00" + n).slice(-2);
        };
        /**
         * Creates a date but allows the month and date to overflow.
         * @private
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @param {?} hours
         * @param {?} minutes
         * @return {?}
         */
        NativeDatetimeAdapter.prototype._createDateWithOverflow = function (year, month, date, hours, minutes) {
            /** @type {?} */
            var result = new Date(year, month, date, hours, minutes);
            // We need to correct for the fact that JS native Date treats years in range [0, 99] as
            // abbreviations for 19xx.
            if (year >= 0 && year < 100) {
                result.setFullYear(this.getYear(result) - 1900);
            }
            return result;
        };
        return NativeDatetimeAdapter;
    }(DatetimeAdapter));
    NativeDatetimeAdapter.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NativeDatetimeAdapter.ctorParameters = function () { return [
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_LOCALE,] }] },
        { type: core$1.DateAdapter }
    ]; };

    /**
     * @fileoverview added by tsickle
     * Generated from: adapter/native-datetime-formats.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAT_NATIVE_DATETIME_FORMATS = {
        parse: {},
        display: {
            dateInput: { year: "numeric", month: "2-digit", day: "2-digit" },
            monthInput: { month: "long" },
            datetimeInput: { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" },
            timeInput: { hour: "2-digit", minute: "2-digit" },
            monthYearLabel: { year: "numeric", month: "short" },
            dateA11yLabel: { year: "numeric", month: "long", day: "numeric" },
            monthYearA11yLabel: { year: "numeric", month: "long" },
            popupHeaderDateLabel: { weekday: "short", month: "short", day: "2-digit" }
        }
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: adapter/adapter.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable max-classes-per-file
    var NativeDatetimeModule = /** @class */ (function () {
        function NativeDatetimeModule() {
        }
        return NativeDatetimeModule;
    }());
    NativeDatetimeModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [core$1.NativeDateModule],
                    providers: [
                        {
                            provide: DatetimeAdapter,
                            useClass: NativeDatetimeAdapter
                        }
                    ]
                },] }
    ];
    var ɵ0$1 = MAT_NATIVE_DATETIME_FORMATS;
    var MatNativeDatetimeModule = /** @class */ (function () {
        function MatNativeDatetimeModule() {
        }
        return MatNativeDatetimeModule;
    }());
    MatNativeDatetimeModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        NativeDatetimeModule,
                        core$1.MatNativeDateModule
                    ],
                    providers: [{ provide: MAT_DATETIME_FORMATS, useValue: ɵ0$1 }]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: adapter/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker-animations.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This animation fades in the background color and text content of the
     * select's options. It is time delayed to occur 100ms after the overlay
     * panel has transformed in.
     * @type {?}
     */
    var fadeInContent = animations.trigger("fadeInContent", [
        animations.state("showing", animations.style({ opacity: 1 })),
        animations.transition("void => showing", [
            animations.style({ opacity: 0 }),
            animations.animate("150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
        ])
    ]);
    /** @type {?} */
    var slideCalendar = animations.trigger("slideCalendar", [
        animations.transition("* => left", [
            animations.animate(180, animations.keyframes([
                animations.style({ transform: "translateX(100%)", offset: 0.5 }),
                animations.style({ transform: "translateX(-100%)", offset: 0.51 }),
                animations.style({ transform: "translateX(0)", offset: 1 })
            ]))
        ]),
        animations.transition("* => right", [
            animations.animate(180, animations.keyframes([
                animations.style({ transform: "translateX(-100%)", offset: 0.5 }),
                animations.style({ transform: "translateX(100%)", offset: 0.51 }),
                animations.style({ transform: "translateX(0)", offset: 1 })
            ]))
        ])
    ]);

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker-errors.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @param {?} provider
     * @return {?}
     */
    function createMissingDateImplError(provider) {
        return Error("MatDatetimepicker: No provider found for " + provider + ". You must import one of the following " +
            "modules at your application root: MatNativeDatetimeModule, MatMomentDatetimeModule, or provide a " +
            "custom implementation.");
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker-filtertype.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MatDatetimepickerFilterType = {
        DATE: 0, HOUR: 1, MINUTE: 2,
    };
    MatDatetimepickerFilterType[MatDatetimepickerFilterType.DATE] = 'DATE';
    MatDatetimepickerFilterType[MatDatetimepickerFilterType.HOUR] = 'HOUR';
    MatDatetimepickerFilterType[MatDatetimepickerFilterType.MINUTE] = 'MINUTE';

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/calendar-body.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An internal class that represents the data corresponding to a single calendar cell.
     * \@docs-private
     */
    var MatDatetimepickerCalendarCell = /** @class */ (function () {
        /**
         * @param {?} value
         * @param {?} displayValue
         * @param {?} ariaLabel
         * @param {?} enabled
         */
        function MatDatetimepickerCalendarCell(value, displayValue, ariaLabel, enabled) {
            this.value = value;
            this.displayValue = displayValue;
            this.ariaLabel = ariaLabel;
            this.enabled = enabled;
        }
        return MatDatetimepickerCalendarCell;
    }());
    if (false) {
        /** @type {?} */
        MatDatetimepickerCalendarCell.prototype.value;
        /** @type {?} */
        MatDatetimepickerCalendarCell.prototype.displayValue;
        /** @type {?} */
        MatDatetimepickerCalendarCell.prototype.ariaLabel;
        /** @type {?} */
        MatDatetimepickerCalendarCell.prototype.enabled;
    }
    /**
     * An internal component used to display calendar data in a table.
     * \@docs-private
     */
    var MatDatetimepickerCalendarBody = /** @class */ (function () {
        function MatDatetimepickerCalendarBody() {
            /**
             * The number of columns in the table.
             */
            this.numCols = 7;
            /**
             * Whether to allow selection of disabled cells.
             */
            this.allowDisabledSelection = false;
            /**
             * The cell number of the active cell in the table.
             */
            this.activeCell = 0;
            /**
             * Emits when a new value is selected.
             */
            this.selectedValueChange = new core.EventEmitter();
        }
        Object.defineProperty(MatDatetimepickerCalendarBody.prototype, "_firstRowOffset", {
            /**
             * The number of blank cells to put at the beginning for the first row.
             * @return {?}
             */
            get: function () {
                return this.rows && this.rows.length && this.rows[0].length ?
                    this.numCols - this.rows[0].length : 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} cell
         * @return {?}
         */
        MatDatetimepickerCalendarBody.prototype._cellClicked = function (cell) {
            if (!this.allowDisabledSelection && !cell.enabled) {
                return;
            }
            this.selectedValueChange.emit(cell.value);
        };
        /**
         * @param {?} rowIndex
         * @param {?} colIndex
         * @return {?}
         */
        MatDatetimepickerCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {
            /** @type {?} */
            var cellNumber = rowIndex * this.numCols + colIndex;
            // Account for the fact that the first row may not have as many cells.
            if (rowIndex) {
                cellNumber -= this._firstRowOffset;
            }
            return cellNumber === this.activeCell;
        };
        return MatDatetimepickerCalendarBody;
    }());
    MatDatetimepickerCalendarBody.decorators = [
        { type: core.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: "[mat-datetimepicker-calendar-body]",
                    template: "<!--\r\n  If there's not enough space in the first row, create a separate label row. We mark this row as\r\n  aria-hidden because we don't want it to be read out as one of the weeks in the month.\r\n-->\r\n<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\">\r\n  <td [attr.colspan]=\"numCols\" class=\"mat-datetimepicker-calendar-body-label\">{{ label }}</td>\r\n</tr>\r\n\r\n<!-- Create the first row separately so we can include a special spacer cell. -->\r\n<tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\">\r\n  <!--\r\n    We mark this cell as aria-hidden so it doesn't get read out as one of the days in the week.\r\n  -->\r\n  <td *ngIf=\"rowIndex === 0 && _firstRowOffset\"\r\n      [attr.colspan]=\"_firstRowOffset\"\r\n      aria-hidden=\"true\"\r\n      class=\"mat-datetimepicker-calendar-body-label\">\r\n    {{ _firstRowOffset >= labelMinRequiredCells ? label : '' }}\r\n  </td>\r\n  <td (click)=\"_cellClicked(item)\"\r\n      *ngFor=\"let item of row; let colIndex = index\"\r\n      [attr.aria-disabled]=\"!item.enabled || null\"\r\n      [attr.aria-label]=\"item.ariaLabel\"\r\n      [class.mat-datetimepicker-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\r\n      [class.mat-datetimepicker-calendar-body-disabled]=\"!item.enabled\"\r\n      class=\"mat-datetimepicker-calendar-body-cell\"\r\n      role=\"button\">\r\n    <div [attr.aria-selected]=\"selectedValue === item.value\"\r\n         [class.mat-datetimepicker-calendar-body-selected]=\"selectedValue === item.value\"\r\n         [class.mat-datetimepicker-calendar-body-today]=\"todayValue === item.value\"\r\n         class=\"mat-datetimepicker-calendar-body-cell-content\">\r\n      {{ item.displayValue }}\r\n    </div>\r\n  </td>\r\n</tr>\r\n",
                    host: {
                        "class": "mat-datetimepicker-calendar-body"
                    },
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".mat-datetimepicker-calendar-body{font-size:13px;min-width:224px}.mat-datetimepicker-calendar-body-label{color:rgba(0,0,0,.54);height:0;line-height:0;padding:7.1428571429% 0 7.1428571429% 7.1428571429%;text-align:left;transform:translateX(-6px)}.mat-datetimepicker-calendar-body-cell{cursor:pointer;height:0;line-height:0;outline:none;padding:7.1428571429% 0;position:relative;text-align:center;width:14.2857142857%}.mat-datetimepicker-calendar-body-disabled{cursor:default;pointer-events:none}.mat-datetimepicker-calendar-body-cell-content{align-items:center;border:1px solid transparent;border-radius:50px;box-sizing:border-box;color:rgba(0,0,0,.87);display:flex;height:90%;justify-content:center;left:5%;position:absolute;top:5%;width:90%}.mat-datetimepicker-calendar-body-disabled>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected){color:rgba(0,0,0,.38)}.mat-datetimepicker-calendar-body-active>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected),:not(.mat-datetimepicker-calendar-body-disabled):hover>.mat-datetimepicker-calendar-body-cell-content:not(.mat-datetimepicker-calendar-body-selected){background-color:rgba(0,0,0,.12)}.mat-datetimepicker-calendar-body-disabled>.mat-datetimepicker-calendar-body-today:not(.mat-datetimepicker-calendar-body-selected){border-color:rgba(0,0,0,.18)}[dir=rtl] .mat-datetimepicker-calendar-body-label{padding:0 7.1428571429% 0 0;text-align:right;transform:translateX(6px)}"]
                }] }
    ];
    MatDatetimepickerCalendarBody.propDecorators = {
        label: [{ type: core.Input }],
        rows: [{ type: core.Input }],
        todayValue: [{ type: core.Input }],
        selectedValue: [{ type: core.Input }],
        labelMinRequiredCells: [{ type: core.Input }],
        numCols: [{ type: core.Input }],
        allowDisabledSelection: [{ type: core.Input }],
        activeCell: [{ type: core.Input }],
        selectedValueChange: [{ type: core.Output }]
    };
    if (false) {
        /**
         * The label for the table. (e.g. "Jan 2017").
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.label;
        /**
         * The cells to display in the table.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.rows;
        /**
         * The value in the table that corresponds to today.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.todayValue;
        /**
         * The value in the table that is currently selected.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.selectedValue;
        /**
         * The minimum number of free cells needed to fit the label in the first row.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.labelMinRequiredCells;
        /**
         * The number of columns in the table.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.numCols;
        /**
         * Whether to allow selection of disabled cells.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.allowDisabledSelection;
        /**
         * The cell number of the active cell in the table.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.activeCell;
        /**
         * Emits when a new value is selected.
         * @type {?}
         */
        MatDatetimepickerCalendarBody.prototype.selectedValueChange;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/multi-year-view.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var yearsPerPage = 24;
    /** @type {?} */
    var yearsPerRow = 4;
    /**
     * An internal component used to display multiple years in the datepicker.
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerMultiYearView = /** @class */ (function () {
        /**
         * @param {?} _adapter
         * @param {?} _dateFormats
         */
        function MatDatetimepickerMultiYearView(_adapter, _dateFormats) {
            this._adapter = _adapter;
            this._dateFormats = _dateFormats;
            this._userSelection = new core.EventEmitter();
            this.type = "date";
            /**
             * Emits when a new month is selected.
             */
            this.selectedChange = new core.EventEmitter();
            if (!this._adapter) {
                throw createMissingDateImplError("DatetimeAdapter");
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError("MAT_DATETIME_FORMATS");
            }
            this._activeDate = this._adapter.today();
        }
        Object.defineProperty(MatDatetimepickerMultiYearView.prototype, "activeDate", {
            /**
             * The date to display in this multi year view
             * @return {?}
             */
            get: function () {
                return this._activeDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var oldActiveDate = this._activeDate;
                this._activeDate = value || this._adapter.today();
                if (oldActiveDate && this._activeDate &&
                    !isSameMultiYearView(this._adapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {
                    this._init();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerMultiYearView.prototype, "selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._selected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selected = value;
                this._selectedYear = this._selected && this._adapter.getYear(this._selected);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerMultiYearView.prototype, "minDate", {
            /**
             * The minimum selectable date.
             * @return {?}
             */
            get: function () {
                return this._minDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._minDate = this._getValidDateOrNull(this._adapter.deserialize(value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerMultiYearView.prototype, "maxDate", {
            /**
             * The maximum selectable date.
             * @return {?}
             */
            get: function () {
                return this._maxDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._maxDate = this._getValidDateOrNull(this._adapter.deserialize(value));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /**
         * Handles when a new year is selected.
         * @param {?} year
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._yearSelected = function (year) {
            /** @type {?} */
            var month = this._adapter.getMonth(this.activeDate);
            /** @type {?} */
            var normalizedDate = this._adapter.createDatetime(year, month, 1, 0, 0);
            this.selectedChange.emit(this._adapter.createDatetime(year, month, Math.min(this._adapter.getDate(this.activeDate), this._adapter.getNumDaysInMonth(normalizedDate)), this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));
            if (this.type === "year") {
                this._userSelection.emit();
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._getActiveCell = function () {
            return getActiveOffset(this._adapter, this.activeDate, this.minDate, this.maxDate);
        };
        /**
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._calendarStateDone = function () {
            this._calendarState = "";
        };
        /**
         * Initializes this year view.
         * @private
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._init = function () {
            var _this = this;
            this._todayYear = this._adapter.getYear(this._adapter.today());
            this._yearLabel = this._adapter.getYearName(this.activeDate);
            /** @type {?} */
            var activeYear = this._adapter.getYear(this.activeDate);
            /** @type {?} */
            var minYearOfPage = activeYear - getActiveOffset(this._adapter, this.activeDate, this.minDate, this.maxDate);
            this._years = [];
            for (var i = 0, row = []; i < yearsPerPage; i++) {
                row.push(minYearOfPage + i);
                if (row.length == yearsPerRow) {
                    this._years.push(row.map(( /**
                     * @param {?} year
                     * @return {?}
                     */function (/**
                     * @param {?} year
                     * @return {?}
                     */ year) { return _this._createCellForYear(year); })));
                    row = [];
                }
            }
        };
        /**
         * Creates an MatDatetimepickerCalendarCell for the given year.
         * @private
         * @param {?} year
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._createCellForYear = function (year) {
            /** @type {?} */
            var yearName = this._adapter.getYearName(this._adapter.createDate(year, 0, 1));
            return new MatDatetimepickerCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
        };
        /**
         * Whether the given year is enabled.
         * @private
         * @param {?} year
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._shouldEnableYear = function (year) {
            // disable if the year is greater than maxDate lower than minDate
            if (year === undefined || year === null ||
                (this.maxDate && year > this._adapter.getYear(this.maxDate)) ||
                (this.minDate && year < this._adapter.getYear(this.minDate))) {
                return false;
            }
            // enable if it reaches here and there's no filter defined
            if (!this.dateFilter) {
                return true;
            }
            /** @type {?} */
            var firstOfYear = this._adapter.createDate(year, 0, 1);
            // If any date in the year is enabled count the year as enabled.
            for (var date = firstOfYear; this._adapter.getYear(date) == year; date = this._adapter.addCalendarDays(date, 1)) {
                if (this.dateFilter(date)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Gets the year in this years range that the given Date falls on.
         * Returns null if the given Date is not in this range.
         * @private
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._getYearInCurrentRange = function (date) {
            /** @type {?} */
            var year = this._adapter.getYear(date);
            return this._isInRange(year) ?
                year : null;
        };
        /**
         * Validate if the current year is in the current range
         * Returns true if is in range else returns false
         * @private
         * @param {?} year
         * @return {?}
         */
        MatDatetimepickerMultiYearView.prototype._isInRange = function (year) {
            return true;
        };
        /**
         * @private
         * @param {?} obj The object to check.
         * @return {?} The given object if it is both a date instance and valid, otherwise null.
         */
        MatDatetimepickerMultiYearView.prototype._getValidDateOrNull = function (obj) {
            return (this._adapter.isDateInstance(obj) && this._adapter.isValid(obj)) ? obj : null;
        };
        return MatDatetimepickerMultiYearView;
    }());
    MatDatetimepickerMultiYearView.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-multi-year-view",
                    template: "<table class=\"mat-datetimepicker-calendar-table\">\r\n  <thead class=\"mat-datetimepicker-calendar-table-header\"></thead>\r\n  <tbody (@slideCalendar.done)=\"_calendarStateDone()\"\r\n         (selectedValueChange)=\"_yearSelected($event)\"\r\n         [@slideCalendar]=\"_calendarState\"\r\n         [activeCell]=\"_getActiveCell()\"\r\n         [numCols]=\"4\"\r\n         [rows]=\"_years\"\r\n         [selectedValue]=\"_selectedYear\"\r\n         [todayValue]=\"_todayYear\"\r\n         allowDisabledSelection=\"true\"\r\n         mat-datetimepicker-calendar-body\r\n         role=\"grid\"></tbody>\r\n</table>\r\n",
                    animations: [slideCalendar],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerMultiYearView.ctorParameters = function () { return [
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATETIME_FORMATS,] }] }
    ]; };
    MatDatetimepickerMultiYearView.propDecorators = {
        _userSelection: [{ type: core.Output }],
        type: [{ type: core.Input }],
        dateFilter: [{ type: core.Input }],
        selectedChange: [{ type: core.Output }],
        activeDate: [{ type: core.Input }],
        selected: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerMultiYearView.prototype._userSelection;
        /** @type {?} */
        MatDatetimepickerMultiYearView.prototype.type;
        /**
         * A function used to filter which dates are selectable.
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype.dateFilter;
        /**
         * Emits when a new month is selected.
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype.selectedChange;
        /**
         * Grid of calendar cells representing the years in the range.
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype._years;
        /**
         * The label for this year range (e.g. "2000-2020").
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype._yearLabel;
        /**
         * The year in this range that today falls on. Null if today is in a different range.
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype._todayYear;
        /**
         * The year in this range that the selected Date falls on.
         * Null if the selected Date is in a different range.
         * @type {?}
         */
        MatDatetimepickerMultiYearView.prototype._selectedYear;
        /** @type {?} */
        MatDatetimepickerMultiYearView.prototype._calendarState;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMultiYearView.prototype._activeDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMultiYearView.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMultiYearView.prototype._minDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMultiYearView.prototype._maxDate;
        /** @type {?} */
        MatDatetimepickerMultiYearView.prototype._adapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMultiYearView.prototype._dateFormats;
    }
    /**
     * @template D
     * @param {?} dateAdapter
     * @param {?} date1
     * @param {?} date2
     * @param {?} minDate
     * @param {?} maxDate
     * @return {?}
     */
    function isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {
        /** @type {?} */
        var year1 = dateAdapter.getYear(date1);
        /** @type {?} */
        var year2 = dateAdapter.getYear(date2);
        /** @type {?} */
        var startingYear = getStartingYear(dateAdapter, minDate, maxDate);
        return Math.floor((year1 - startingYear) / yearsPerPage) ===
            Math.floor((year2 - startingYear) / yearsPerPage);
    }
    /**
     * When the multi-year view is first opened, the active year will be in view.
     * So we compute how many years are between the active year and the *slot* where our
     * "startingYear" will render when paged into view.
     * @template D
     * @param {?} dateAdapter
     * @param {?} activeDate
     * @param {?} minDate
     * @param {?} maxDate
     * @return {?}
     */
    function getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {
        /** @type {?} */
        var activeYear = dateAdapter.getYear(activeDate);
        return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);
    }
    /**
     * We pick a "starting" year such that either the maximum year would be at the end
     * or the minimum year would be at the beginning of a page.
     * @template D
     * @param {?} dateAdapter
     * @param {?} minDate
     * @param {?} maxDate
     * @return {?}
     */
    function getStartingYear(dateAdapter, minDate, maxDate) {
        /** @type {?} */
        var startingYear = 0;
        if (maxDate) {
            /** @type {?} */
            var maxYear = dateAdapter.getYear(maxDate);
            startingYear = maxYear - yearsPerPage + 1;
        }
        else if (minDate) {
            startingYear = dateAdapter.getYear(minDate);
        }
        return startingYear;
    }
    /**
     * Gets remainder that is non-negative, even if first number is negative
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function euclideanModulo(a, b) {
        return (a % b + b) % b;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/calendar.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A calendar that is used as part of the datepicker.
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerCalendar = /** @class */ (function () {
        /**
         * @param {?} _elementRef
         * @param {?} _intl
         * @param {?} _ngZone
         * @param {?} _adapter
         * @param {?} _dateFormats
         * @param {?} changeDetectorRef
         */
        function MatDatetimepickerCalendar(_elementRef, _intl, _ngZone, _adapter, _dateFormats, changeDetectorRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._intl = _intl;
            this._ngZone = _ngZone;
            this._adapter = _adapter;
            this._dateFormats = _dateFormats;
            this._userSelection = new core.EventEmitter();
            /**
             * Active multi year view when click on year.
             */
            this.multiYearSelector = false;
            /**
             * Whether the calendar should be started in month or year view.
             */
            this.startView = "month";
            this.twelvehour = false;
            this.timeInterval = 1;
            this.ariaLabel = "Use arrow keys to navigate";
            this.ariaNextMonthLabel = "Next month";
            this.ariaPrevMonthLabel = "Previous month";
            this.ariaNextYearLabel = "Next year";
            this.ariaPrevYearLabel = "Previous year";
            this.ariaNextMultiYearLabel = "Next year range";
            this.ariaPrevMultiYearLabel = "Previous year range";
            /**
             * Emits when the currently selected date changes.
             */
            this.selectedChange = new core.EventEmitter();
            /**
             * Emits when the view has been changed. *
             */
            this.viewChanged = new core.EventEmitter();
            this._clockView = "hour";
            this._type = "date";
            /**
             * Date filter for the month and year views.
             */
            this._dateFilterForViews = ( /**
             * @param {?} date
             * @return {?}
             */function (date) {
                return !!date &&
                    (!_this.dateFilter || _this.dateFilter(date, MatDatetimepickerFilterType.DATE)) &&
                    (!_this.minDate || _this._adapter.compareDate(date, _this.minDate) >= 0) &&
                    (!_this.maxDate || _this._adapter.compareDate(date, _this.maxDate) <= 0);
            });
            if (!this._adapter) {
                throw createMissingDateImplError("DatetimeAdapter");
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError("MAT_DATETIME_FORMATS");
            }
            this._intlChanges = _intl.changes.subscribe(( /**
             * @return {?}
             */function () { return changeDetectorRef.markForCheck(); }));
        }
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "type", {
            /**
             * @return {?}
             */
            get: function () {
                return this._type;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._type = value || "date";
                if (this.type === "year") {
                    this.multiYearSelector = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "startAt", {
            /**
             * A date representing the period (month or year) to start the calendar in.
             * @return {?}
             */
            get: function () {
                return this._startAt;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._startAt = this._adapter.getValidDateOrNull(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._selected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selected = this._adapter.getValidDateOrNull(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "minDate", {
            /**
             * The minimum selectable date.
             * @return {?}
             */
            get: function () {
                return this._minDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._minDate = this._adapter.getValidDateOrNull(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "maxDate", {
            /**
             * The maximum selectable date.
             * @return {?}
             */
            get: function () {
                return this._maxDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._maxDate = this._adapter.getValidDateOrNull(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_activeDate", {
            /**
             * The current active date. This determines which time period is shown and which date is
             * highlighted when using keyboard navigation.
             * @return {?}
             */
            get: function () {
                return this._clampedActiveDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var oldActiveDate = this._clampedActiveDate;
                this._clampedActiveDate = this._adapter.clampDate(value, this.minDate, this.maxDate);
                if (oldActiveDate && this._clampedActiveDate && this.currentView === "month" &&
                    !this._adapter.sameMonthAndYear(oldActiveDate, this._clampedActiveDate)) {
                    if (this._adapter.isInNextMonth(oldActiveDate, this._clampedActiveDate)) {
                        this.calendarState("right");
                    }
                    else {
                        this.calendarState("left");
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "currentView", {
            /**
             * @return {?}
             */
            get: function () {
                return this._currentView;
            },
            /**
             * @param {?} view
             * @return {?}
             */
            set: function (view) {
                this._currentView = view;
                this.viewChanged.emit(view);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_yearLabel", {
            /**
             * The label for the current calendar view.
             * @return {?}
             */
            get: function () {
                return this._adapter.getYearName(this._activeDate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_monthYearLabel", {
            /**
             * @return {?}
             */
            get: function () {
                if (this.currentView === "multi-year") {
                    // The offset from the active year to the "slot" for the starting year is the
                    // *actual* first rendered year in the multi-year view, and the last year is
                    // just yearsPerPage - 1 away.
                    /** @type {?} */
                    var activeYear = this._adapter.getYear(this._activeDate);
                    /** @type {?} */
                    var minYearOfPage = activeYear - getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate);
                    /** @type {?} */
                    var maxYearOfPage = minYearOfPage + yearsPerPage - 1;
                    /** @type {?} */
                    var minYearName = this._adapter.getYearName(this._adapter.createDate(minYearOfPage, 0, 1));
                    /** @type {?} */
                    var maxYearName = this._adapter.getYearName(this._adapter.createDate(maxYearOfPage, 0, 1));
                    return this._intl.formatYearRange(minYearName, maxYearName);
                }
                return this.currentView === "month" ? this._adapter.getMonthNames("long")[this._adapter.getMonth(this._activeDate)] :
                    this._adapter.getYearName(this._activeDate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_dateLabel", {
            /**
             * @return {?}
             */
            get: function () {
                switch (this.type) {
                    case "month":
                        return this._adapter.getMonthNames("long")[this._adapter.getMonth(this._activeDate)];
                    default:
                        return this._adapter.format(this._activeDate, this._dateFormats.display.popupHeaderDateLabel);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_hoursLabel", {
            /**
             * @return {?}
             */
            get: function () {
                /** @type {?} */
                var hour = this._adapter.getHour(this._activeDate);
                if (!!this.twelvehour) {
                    if (hour === 0) {
                        hour = 24;
                    }
                    hour = hour > 12 ? (hour - 12) : hour;
                }
                return this._2digit(hour);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_minutesLabel", {
            /**
             * @return {?}
             */
            get: function () {
                return this._2digit(this._adapter.getMinute(this._activeDate));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_ariaLabelNext", {
            /**
             * @return {?}
             */
            get: function () {
                switch (this._currentView) {
                    case "month":
                        return this.ariaNextMonthLabel;
                    case "year":
                        return this.ariaNextYearLabel;
                    case "multi-year":
                        return this.ariaNextMultiYearLabel;
                    default:
                        return "";
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerCalendar.prototype, "_ariaLabelPrev", {
            /**
             * @return {?}
             */
            get: function () {
                switch (this._currentView) {
                    case "month":
                        return this.ariaPrevMonthLabel;
                    case "year":
                        return this.ariaPrevYearLabel;
                    case "multi-year":
                        return this.ariaPrevMultiYearLabel;
                    default:
                        return "";
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._userSelected = function () {
            this._userSelection.emit();
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype.ngAfterContentInit = function () {
            this._activeDate = this.startAt || this._adapter.today();
            this._selectAMPM(this._activeDate);
            this._focusActiveCell();
            if (this.type === "year") {
                this.currentView = "multi-year";
            }
            else if (this.type === "month") {
                this.currentView = "year";
            }
            else if (this.type === "time") {
                this.currentView = "clock";
            }
            else {
                this.currentView = this.startView || "month";
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
        };
        /**
         * Handles date selection in the month view.
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._dateSelected = function (date) {
            if (this.type === "date") {
                if (!this._adapter.sameDate(date, this.selected)) {
                    this.selectedChange.emit(date);
                }
            }
            else {
                this._activeDate = date;
                this.currentView = "clock";
            }
        };
        /**
         * Handles month selection in the year view.
         * @param {?} month
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._monthSelected = function (month) {
            if (this.type === "month") {
                if (!this._adapter.sameMonthAndYear(month, this.selected)) {
                    this.selectedChange.emit(this._adapter.getFirstDateOfMonth(month));
                }
            }
            else {
                this._activeDate = month;
                this.currentView = "month";
                this._clockView = "hour";
            }
        };
        /**
         * Handles year selection in the multi year view.
         * @param {?} year
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._yearSelected = function (year) {
            if (this.type === "year") {
                if (!this._adapter.sameYear(year, this.selected)) {
                    /** @type {?} */
                    var normalizedDate = this._adapter.createDatetime(this._adapter.getYear(year), 0, 1, 0, 0);
                    this.selectedChange.emit(normalizedDate);
                }
            }
            else {
                this._activeDate = year;
                this.currentView = "year";
            }
        };
        /**
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._timeSelected = function (date) {
            if (this._clockView !== "minute") {
                this._activeDate = this._updateDate(date);
                this._clockView = "minute";
            }
            else {
                if (!this._adapter.sameDatetime(date, this.selected)) {
                    this.selectedChange.emit(date);
                }
            }
        };
        /**
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._onActiveDateChange = function (date) {
            this._activeDate = date;
        };
        /**
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._updateDate = function (date) {
            if (!!this.twelvehour) {
                /** @type {?} */
                var HOUR = this._adapter.getHour(date);
                if (HOUR === 12) {
                    if (this._AMPM === "AM") {
                        return this._adapter.addCalendarHours(date, -12);
                    }
                }
                else if (this._AMPM === "PM") {
                    return this._adapter.addCalendarHours(date, 12);
                }
            }
            return date;
        };
        /**
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._selectAMPM = function (date) {
            if (this._adapter.getHour(date) > 11) {
                this._AMPM = "PM";
            }
            else {
                this._AMPM = "AM";
            }
        };
        /**
         * @param {?} source
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._ampmClicked = function (source) {
            if (source === this._AMPM) {
                return;
            }
            this._AMPM = source;
            if (this._AMPM === "AM") {
                this._activeDate = this._adapter.addCalendarHours(this._activeDate, -12);
            }
            else {
                this._activeDate = this._adapter.addCalendarHours(this._activeDate, 12);
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._yearClicked = function () {
            if (this.type === "year" || this.multiYearSelector) {
                this.currentView = "multi-year";
                return;
            }
            this.currentView = "year";
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._dateClicked = function () {
            if (this.type !== "month") {
                this.currentView = "month";
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._hoursClicked = function () {
            this.currentView = "clock";
            this._clockView = "hour";
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._minutesClicked = function () {
            this.currentView = "clock";
            this._clockView = "minute";
        };
        /**
         * Handles user clicks on the previous button.
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._previousClicked = function () {
            this._activeDate = this.currentView === "month" ?
                this._adapter.addCalendarMonths(this._activeDate, -1) :
                this._adapter.addCalendarYears(this._activeDate, this.currentView === "year" ? -1 : -yearsPerPage);
        };
        /**
         * Handles user clicks on the next button.
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._nextClicked = function () {
            this._activeDate = this.currentView === "month" ?
                this._adapter.addCalendarMonths(this._activeDate, 1) :
                this._adapter.addCalendarYears(this._activeDate, this.currentView === "year" ? 1 : yearsPerPage);
        };
        /**
         * Whether the previous period button is enabled.
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._previousEnabled = function () {
            if (!this.minDate) {
                return true;
            }
            return !this.minDate || !this._isSameView(this._activeDate, this.minDate);
        };
        /**
         * Whether the next period button is enabled.
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._nextEnabled = function () {
            return !this.maxDate || !this._isSameView(this._activeDate, this.maxDate);
        };
        /**
         * Handles keydown events on the calendar body.
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._handleCalendarBodyKeydown = function (event) {
            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
            // disabled ones from being selected. This may not be ideal, we should look into whether
            // navigation should skip over disabled dates, and if so, how to implement that efficiently.
            if (this.currentView === "month") {
                this._handleCalendarBodyKeydownInMonthView(event);
            }
            else if (this.currentView === "year") {
                this._handleCalendarBodyKeydownInYearView(event);
            }
            else if (this.currentView === "multi-year") {
                this._handleCalendarBodyKeydownInMultiYearView(event);
            }
            else {
                this._handleCalendarBodyKeydownInClockView(event);
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._focusActiveCell = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                _this._ngZone.onStable.asObservable().pipe(operators.first()).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this._elementRef.nativeElement.focus();
                }));
            }));
        };
        /**
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._calendarStateDone = function () {
            this._calendarState = "";
        };
        /**
         * Whether the two dates represent the same view in the current view mode (month or year).
         * @private
         * @param {?} date1
         * @param {?} date2
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._isSameView = function (date1, date2) {
            if (this.currentView === "month") {
                return this._adapter.getYear(date1) === this._adapter.getYear(date2) &&
                    this._adapter.getMonth(date1) === this._adapter.getMonth(date2);
            }
            if (this.currentView === "year") {
                return this._adapter.getYear(date1) === this._adapter.getYear(date2);
            }
            // Otherwise we are in 'multi-year' view.
            return isSameMultiYearView(this._adapter, date1, date2, this.minDate, this.maxDate);
        };
        /**
         * Handles keydown events on the calendar body when calendar is in month view.
         * @private
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._handleCalendarBodyKeydownInMonthView = function (event) {
            // tslint:disable-next-line:deprecation
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, 1);
                    break;
                case keycodes.UP_ARROW:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, -7);
                    break;
                case keycodes.DOWN_ARROW:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, 7);
                    break;
                case keycodes.HOME:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, 1 - this._adapter.getDate(this._activeDate));
                    break;
                case keycodes.END:
                    this._activeDate = this._adapter.addCalendarDays(this._activeDate, (this._adapter.getNumDaysInMonth(this._activeDate) -
                        this._adapter.getDate(this._activeDate)));
                    break;
                case keycodes.PAGE_UP:
                    this._activeDate = event.altKey ?
                        this._adapter.addCalendarYears(this._activeDate, -1) :
                        this._adapter.addCalendarMonths(this._activeDate, -1);
                    break;
                case keycodes.PAGE_DOWN:
                    this._activeDate = event.altKey ?
                        this._adapter.addCalendarYears(this._activeDate, 1) :
                        this._adapter.addCalendarMonths(this._activeDate, 1);
                    break;
                case keycodes.ENTER:
                    if (this._dateFilterForViews(this._activeDate)) {
                        this._dateSelected(this._activeDate);
                        // Prevent unexpected default actions such as form submission.
                        event.preventDefault();
                    }
                    return;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        /**
         * Handles keydown events on the calendar body when calendar is in year view.
         * @private
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._handleCalendarBodyKeydownInYearView = function (event) {
            // tslint:disable-next-line:deprecation
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this._activeDate = this._adapter.addCalendarMonths(this._activeDate, -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this._activeDate = this._adapter.addCalendarMonths(this._activeDate, 1);
                    break;
                case keycodes.UP_ARROW:
                    this._activeDate = this._prevMonthInSameCol(this._activeDate);
                    break;
                case keycodes.DOWN_ARROW:
                    this._activeDate = this._nextMonthInSameCol(this._activeDate);
                    break;
                case keycodes.HOME:
                    this._activeDate = this._adapter.addCalendarMonths(this._activeDate, -this._adapter.getMonth(this._activeDate));
                    break;
                case keycodes.END:
                    this._activeDate = this._adapter.addCalendarMonths(this._activeDate, 11 - this._adapter.getMonth(this._activeDate));
                    break;
                case keycodes.PAGE_UP:
                    this._activeDate =
                        this._adapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                    break;
                case keycodes.PAGE_DOWN:
                    this._activeDate =
                        this._adapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                    break;
                case keycodes.ENTER:
                    this._monthSelected(this._activeDate);
                    break;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        /**
         * Handles keydown events on the calendar body when calendar is in multi-year view.
         * @private
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._handleCalendarBodyKeydownInMultiYearView = function (event) {
            // tslint:disable-next-line:deprecation
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, 1);
                    break;
                case keycodes.UP_ARROW:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, -yearsPerRow);
                    break;
                case keycodes.DOWN_ARROW:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, yearsPerRow);
                    break;
                case keycodes.HOME:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, -getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate));
                    break;
                case keycodes.END:
                    this._activeDate = this._adapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._adapter, this._activeDate, this.minDate, this.maxDate) - 1);
                    break;
                case keycodes.PAGE_UP:
                    this._activeDate =
                        this._adapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                    break;
                case keycodes.PAGE_DOWN:
                    this._activeDate =
                        this._adapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                    break;
                case keycodes.ENTER:
                    this._yearSelected(this._activeDate);
                    break;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
        };
        /**
         * Handles keydown events on the calendar body when calendar is in month view.
         * @private
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._handleCalendarBodyKeydownInClockView = function (event) {
            // tslint:disable-next-line:deprecation
            switch (event.keyCode) {
                case keycodes.UP_ARROW:
                    this._activeDate = this._clockView === "hour" ?
                        this._adapter.addCalendarHours(this._activeDate, 1) :
                        this._adapter.addCalendarMinutes(this._activeDate, 1);
                    break;
                case keycodes.DOWN_ARROW:
                    this._activeDate = this._clockView === "hour" ?
                        this._adapter.addCalendarHours(this._activeDate, -1) :
                        this._adapter.addCalendarMinutes(this._activeDate, -1);
                    break;
                case keycodes.ENTER:
                    this._timeSelected(this._activeDate);
                    return;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        /**
         * Determine the date for the month that comes before the given month in the same column in the
         * calendar table.
         * @private
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._prevMonthInSameCol = function (date) {
            // Determine how many months to jump forward given that there are 2 empty slots at the beginning
            // of each year.
            /** @type {?} */
            var increment = this._adapter.getMonth(date) <= 4 ? -5 :
                (this._adapter.getMonth(date) >= 7 ? -7 : -12);
            return this._adapter.addCalendarMonths(date, increment);
        };
        /**
         * Determine the date for the month that comes after the given month in the same column in the
         * calendar table.
         * @private
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._nextMonthInSameCol = function (date) {
            // Determine how many months to jump forward given that there are 2 empty slots at the beginning
            // of each year.
            /** @type {?} */
            var increment = this._adapter.getMonth(date) <= 4 ? 7 :
                (this._adapter.getMonth(date) >= 7 ? 5 : 12);
            return this._adapter.addCalendarMonths(date, increment);
        };
        /**
         * @private
         * @param {?} direction
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype.calendarState = function (direction) {
            this._calendarState = direction;
        };
        /**
         * @private
         * @param {?} n
         * @return {?}
         */
        MatDatetimepickerCalendar.prototype._2digit = function (n) {
            return ("00" + n).slice(-2);
        };
        return MatDatetimepickerCalendar;
    }());
    MatDatetimepickerCalendar.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-calendar",
                    template: "<div class=\"mat-datetimepicker-calendar-header\">\r\n  <div (click)=\"_yearClicked()\"\r\n       *ngIf=\"type !== 'time'\"\r\n       [class.active]=\"currentView === 'year' || currentView === 'multi-year'\"\r\n       class=\"mat-datetimepicker-calendar-header-year\"\r\n       role=\"button\">{{ _yearLabel }}\r\n    <mat-icon *ngIf=\"multiYearSelector || type === 'year'\">arrow_drop_down</mat-icon>\r\n  </div>\r\n  <div class=\"mat-datetimepicker-calendar-header-date-time\">\r\n    <span (click)=\"_dateClicked()\" *ngIf=\"type !== 'time' && type !== 'year'\"\r\n          [class.active]=\"currentView === 'month'\"\r\n          [class.not-clickable]=\"type === 'month'\"\r\n          class=\"mat-datetimepicker-calendar-header-date\"\r\n          role=\"button\">{{ _dateLabel }}</span>\r\n    <span *ngIf=\"type.endsWith('time')\"\r\n          [class.active]=\"currentView === 'clock'\"\r\n          class=\"mat-datetimepicker-calendar-header-time\">\r\n      <span (click)=\"_hoursClicked()\"\r\n            [class.active]=\"_clockView == 'hour'\"\r\n            class=\"mat-datetimepicker-calendar-header-hours\"\r\n            role=\"button\">{{ _hoursLabel }}</span>:<span (click)=\"_minutesClicked()\"\r\n                                                                     [class.active]=\"_clockView == 'minute'\"\r\n                                                                     class=\"mat-datetimepicker-calendar-header-minutes\"\r\n                                                                     role=\"button\">{{ _minutesLabel }}</span>\r\n      <br/>\r\n      <span *ngIf=\"twelvehour\"\r\n            class=\"mat-datetimepicker-calendar-header-ampm-container\">\r\n        <span (click)=\"_ampmClicked('AM')\"\r\n              [class.active]=\"_AMPM === 'AM'\"\r\n              class=\"mat-datetimepicker-calendar-header-ampm\">AM</span>/<span (click)=\"_ampmClicked('PM')\"\r\n                                                           [class.active]=\"_AMPM === 'PM'\"\r\n                                                           class=\"mat-datetimepicker-calendar-header-ampm\">PM</span>\r\n      </span>\r\n    </span>\r\n  </div>\r\n</div>\r\n<div [ngSwitch]=\"currentView\" class=\"mat-datetimepicker-calendar-content\">\r\n  <div *ngIf=\"currentView === 'month' || currentView === 'year' || currentView === 'multi-year'\"\r\n       class=\"mat-month-content\">\r\n    <div class=\"mat-datetimepicker-calendar-controls\">\r\n      <div (click)=\"_previousClicked()\"\r\n           [attr.aria-disabled]=\"!_previousEnabled()\"\r\n           [attr.aria-label]=\"_ariaLabelPrev\"\r\n           [class.disabled]=\"!_previousEnabled()\"\r\n           class=\"mat-datetimepicker-calendar-previous-button\"\r\n           role=\"button\">\r\n        <svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\r\n          <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"></path>\r\n        </svg>\r\n      </div>\r\n      <div (@slideCalendar.done)=\"_calendarStateDone()\" [@slideCalendar]=\"_calendarState\"\r\n           class=\"mat-datetimepicker-calendar-period-button\">\r\n        <strong>{{ _monthYearLabel }}</strong>\r\n      </div>\r\n      <div (click)=\"_nextClicked()\"\r\n           [attr.aria-disabled]=\"!_nextEnabled()\"\r\n           [attr.aria-label]=\"_ariaLabelNext\"\r\n           [class.disabled]=\"!_nextEnabled()\"\r\n           class=\"mat-datetimepicker-calendar-next-button\"\r\n           role=\"button\">\r\n        <svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\r\n          <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path>\r\n        </svg>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <mat-datetimepicker-month-view (_userSelection)=\"_userSelected()\"\r\n                                 (selectedChange)=\"_dateSelected($event)\"\r\n                                 *ngSwitchCase=\"'month'\"\r\n                                 [activeDate]=\"_activeDate\"\r\n                                 [dateFilter]=\"_dateFilterForViews\"\r\n                                 [selected]=\"selected\"\r\n                                 [type]=\"type\">\r\n  </mat-datetimepicker-month-view>\r\n  <mat-datetimepicker-year-view (_userSelection)=\"_userSelected()\"\r\n                                (selectedChange)=\"_monthSelected($event)\"\r\n                                *ngSwitchCase=\"'year'\"\r\n                                [activeDate]=\"_activeDate\"\r\n                                [dateFilter]=\"_dateFilterForViews\"\r\n                                [selected]=\"selected\"\r\n                                [type]=\"type\">\r\n  </mat-datetimepicker-year-view>\r\n  <mat-datetimepicker-multi-year-view (_userSelection)=\"_userSelected()\"\r\n                                      (selectedChange)=\"_yearSelected($event)\"\r\n                                      *ngSwitchCase=\"'multi-year'\"\r\n                                      [activeDate]=\"_activeDate\"\r\n                                      [dateFilter]=\"_dateFilterForViews\"\r\n                                      [maxDate]=\"maxDate\"\r\n                                      [minDate]=\"minDate\"\r\n                                      [selected]=\"selected\"\r\n                                      [type]=\"type\">\r\n  </mat-datetimepicker-multi-year-view>\r\n  <mat-datetimepicker-clock (_userSelection)=\"_userSelected()\"\r\n                            (activeDateChange)=\"_onActiveDateChange($event)\"\r\n                            (selectedChange)=\"_timeSelected($event)\"\r\n                            *ngSwitchDefault\r\n                            [dateFilter]=\"dateFilter\"\r\n                            [interval]=\"timeInterval\"\r\n                            [maxDate]=\"maxDate\"\r\n                            [minDate]=\"minDate\"\r\n                            [selected]=\"_activeDate\"\r\n                            [startView]=\"_clockView\"\r\n                            [twelvehour]=\"twelvehour\">\r\n  </mat-datetimepicker-clock>\r\n</div>\r\n",
                    host: {
                        "[class.mat-datetimepicker-calendar]": "true",
                        "[attr.aria-label]": "ariaLabel",
                        "role": "dialog",
                        "tabindex": "0",
                        "(keydown)": "_handleCalendarBodyKeydown($event)"
                    },
                    animations: [slideCalendar],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".mat-datetimepicker-calendar{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;display:block;outline:none;user-select:none}.mat-datetimepicker-calendar[mode=landscape]{display:flex}.mat-datetimepicker-calendar-header{box-sizing:border-box;color:#fff;font-size:14px;padding:16px}[mode=landscape] .mat-datetimepicker-calendar-header{min-width:150px;width:150px}.mat-datetimepicker-calendar-header-date-time,.mat-datetimepicker-calendar-header-year{font-weight:500;white-space:nowrap;width:100%}.mat-datetimepicker-calendar-header-year{font-size:16px}.mat-datetimepicker-calendar-header-year mat-icon{transform:translateY(5px)}.mat-datetimepicker-calendar-header-date-time{font-size:30px;line-height:34px}[mode=landscape] .mat-datetimepicker-calendar-header-date-time{white-space:normal;word-wrap:break-word}.mat-datetimepicker-calendar-header-ampm-container{font-size:.77em}.mat-datetimepicker-calendar-header-ampm:not(.active),.mat-datetimepicker-calendar-header-date:not(.active),.mat-datetimepicker-calendar-header-hours:not(.active),.mat-datetimepicker-calendar-header-minutes:not(.active),.mat-datetimepicker-calendar-header-year:not(.active){cursor:pointer;opacity:.6}.mat-datetimepicker-calendar-header-ampm.not-clickable,.mat-datetimepicker-calendar-header-date.not-clickable,.mat-datetimepicker-calendar-header-hours.not-clickable,.mat-datetimepicker-calendar-header-minutes.not-clickable,.mat-datetimepicker-calendar-header-year.not-clickable{cursor:auto}.mat-datetimepicker-calendar-header-time{padding-left:8px}.mat-datetimepicker-calendar-header-time:not(.active){opacity:.6}.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-ampm,.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-hours,.mat-datetimepicker-calendar-header-time:not(.active) .mat-datetimepicker-calendar-header-minutes{cursor:pointer;opacity:1}[mode=landscape] .mat-datetimepicker-calendar-header-time{display:block;padding-left:0}.mat-datetimepicker-calendar-content{box-sizing:border-box;outline:none;overflow:hidden;padding:0 8px 8px;width:100%}[mode=landscape] .mat-datetimepicker-calendar-content{padding-top:8px}.mat-datetimepicker-calendar-controls{display:flex;justify-content:space-between}.mat-datetimepicker-calendar-next-button,.mat-datetimepicker-calendar-period-button,.mat-datetimepicker-calendar-previous-button{background:transparent;border:0;box-sizing:border-box;display:inline-block;height:48px;outline:none;padding:12px}.mat-datetimepicker-calendar-next-button,.mat-datetimepicker-calendar-previous-button{cursor:pointer;width:48px}.mat-datetimepicker-calendar-next-button.disabled,.mat-datetimepicker-calendar-previous-button.disabled{color:rgba(0,0,0,.38);pointer-events:none}.mat-datetimepicker-calendar-next-button svg,.mat-datetimepicker-calendar-previous-button svg{fill:currentColor;vertical-align:top}.mat-datetimepicker-calendar-table{border-collapse:collapse;border-spacing:0;width:100%}.mat-datetimepicker-calendar-table-header{color:rgba(0,0,0,.38)}.mat-datetimepicker-calendar-table-header th{font-size:11px;padding:0 0 8px;text-align:center}@media (min-width:480px){.mat-datetimepicker-calendar[mode=auto]{display:flex}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header{min-width:150px;width:150px}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header-date-time{white-space:normal;word-wrap:break-word}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-header-time{display:block;padding-left:0}.mat-datetimepicker-calendar[mode=auto] .mat-datetimepicker-calendar-content{padding-top:8px}}"]
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerCalendar.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: datepicker.MatDatepickerIntl },
        { type: core.NgZone },
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATETIME_FORMATS,] }] },
        { type: core.ChangeDetectorRef }
    ]; };
    MatDatetimepickerCalendar.propDecorators = {
        _userSelection: [{ type: core.Output }],
        multiYearSelector: [{ type: core.Input }],
        startView: [{ type: core.Input }],
        twelvehour: [{ type: core.Input }],
        timeInterval: [{ type: core.Input }],
        dateFilter: [{ type: core.Input }],
        ariaLabel: [{ type: core.Input }],
        ariaNextMonthLabel: [{ type: core.Input }],
        ariaPrevMonthLabel: [{ type: core.Input }],
        ariaNextYearLabel: [{ type: core.Input }],
        ariaPrevYearLabel: [{ type: core.Input }],
        ariaNextMultiYearLabel: [{ type: core.Input }],
        ariaPrevMultiYearLabel: [{ type: core.Input }],
        selectedChange: [{ type: core.Output }],
        viewChanged: [{ type: core.Output }],
        type: [{ type: core.Input }],
        startAt: [{ type: core.Input }],
        selected: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerCalendar.prototype._userSelection;
        /**
         * Active multi year view when click on year.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype.multiYearSelector;
        /**
         * Whether the calendar should be started in month or year view.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype.startView;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.twelvehour;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.timeInterval;
        /**
         * A function used to filter which dates are selectable.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype.dateFilter;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaNextMonthLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaPrevMonthLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaNextYearLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaPrevYearLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaNextMultiYearLabel;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype.ariaPrevMultiYearLabel;
        /**
         * Emits when the currently selected date changes.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype.selectedChange;
        /**
         * Emits when the view has been changed. *
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype.viewChanged;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype._AMPM;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype._clockView;
        /** @type {?} */
        MatDatetimepickerCalendar.prototype._calendarState;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._intlChanges;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._clampedActiveDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._type;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._startAt;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._minDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._maxDate;
        /**
         * Whether the calendar is in month view.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype._currentView;
        /**
         * Date filter for the month and year views.
         * @type {?}
         */
        MatDatetimepickerCalendar.prototype._dateFilterForViews;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._elementRef;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._intl;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._adapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerCalendar.prototype._dateFormats;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/clock.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLOCK_RADIUS = 50;
    /** @type {?} */
    var CLOCK_INNER_RADIUS = 27.5;
    /** @type {?} */
    var CLOCK_OUTER_RADIUS = 41.25;
    /** @type {?} */
    var CLOCK_TICK_RADIUS = 7.0833;
    /**
     * A clock that is used as part of the datepicker.
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerClock = /** @class */ (function () {
        /**
         * @param {?} _element
         * @param {?} _adapter
         */
        function MatDatetimepickerClock(_element, _adapter) {
            var _this = this;
            this._element = _element;
            this._adapter = _adapter;
            this._userSelection = new core.EventEmitter();
            this.interval = 1;
            this.twelvehour = false;
            /**
             * Emits when the currently selected date changes.
             */
            this.selectedChange = new core.EventEmitter();
            this.activeDateChange = new core.EventEmitter();
            /**
             * Hours and Minutes representing the clock view.
             */
            this._hours = [];
            this._minutes = [];
            /**
             * Whether the clock is in hour view.
             */
            this._hourView = true;
            this._timeChanged = false;
            this.mouseMoveListener = ( /**
             * @param {?} event
             * @return {?}
             */function (event) {
                _this._handleMousemove(event);
            });
            this.mouseUpListener = ( /**
             * @return {?}
             */function () {
                _this._handleMouseup();
            });
        }
        Object.defineProperty(MatDatetimepickerClock.prototype, "activeDate", {
            /**
             * The date to display in this clock view.
             * @return {?}
             */
            get: function () {
                return this._activeDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var oldActiveDate = this._activeDate;
                this._activeDate = this._adapter.clampDate(value, this.minDate, this.maxDate);
                if (!this._adapter.sameMinute(oldActiveDate, this._activeDate)) {
                    this._init();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerClock.prototype, "selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._selected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selected = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));
                if (this._selected) {
                    this.activeDate = this._selected;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerClock.prototype, "minDate", {
            /**
             * The minimum selectable date.
             * @return {?}
             */
            get: function () {
                return this._minDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._minDate = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerClock.prototype, "maxDate", {
            /**
             * The maximum selectable date.
             * @return {?}
             */
            get: function () {
                return this._maxDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._maxDate = this._adapter.getValidDateOrNull(this._adapter.deserialize(value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerClock.prototype, "startView", {
            /**
             * Whether the clock should be started in hour or minute view.
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._hourView = value != "minute";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerClock.prototype, "_hand", {
            /**
             * @return {?}
             */
            get: function () {
                /** @type {?} */
                var hour = this._adapter.getHour(this.activeDate);
                if (!!this.twelvehour) {
                    if (hour === 0) {
                        hour = 24;
                    }
                    this._selectedHour = hour > 12 ? (hour - 12) : hour;
                }
                else {
                    this._selectedHour = hour;
                }
                this._selectedMinute = this._adapter.getMinute(this.activeDate);
                /** @type {?} */
                var deg = 0;
                /** @type {?} */
                var radius = CLOCK_OUTER_RADIUS;
                if (this._hourView) {
                    /** @type {?} */
                    var outer = this._selectedHour > 0 && this._selectedHour < 13;
                    radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;
                    if (this.twelvehour) {
                        radius = CLOCK_OUTER_RADIUS;
                    }
                    deg = Math.round(this._selectedHour * (360 / (24 / 2)));
                }
                else {
                    deg = Math.round(this._selectedMinute * (360 / 60));
                }
                return {
                    "transform": "rotate(" + deg + "deg)",
                    "height": radius + "%",
                    "margin-top": 50 - radius + "%"
                };
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerClock.prototype.ngAfterContentInit = function () {
            this.activeDate = this._activeDate || this._adapter.today();
            this._init();
        };
        /**
         * Handles mousedown events on the clock body.
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerClock.prototype._handleMousedown = function (event) {
            this._timeChanged = false;
            this.setTime(event);
            document.addEventListener("mousemove", this.mouseMoveListener);
            document.addEventListener("touchmove", this.mouseMoveListener);
            document.addEventListener("mouseup", this.mouseUpListener);
            document.addEventListener("touchend", this.mouseUpListener);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerClock.prototype._handleMousemove = function (event) {
            event.preventDefault();
            this.setTime(event);
        };
        /**
         * @return {?}
         */
        MatDatetimepickerClock.prototype._handleMouseup = function () {
            document.removeEventListener("mousemove", this.mouseMoveListener);
            document.removeEventListener("touchmove", this.mouseMoveListener);
            document.removeEventListener("mouseup", this.mouseUpListener);
            document.removeEventListener("touchend", this.mouseUpListener);
            if (this._timeChanged) {
                this.selectedChange.emit(this.activeDate);
                if (!this._hourView) {
                    this._userSelection.emit();
                }
            }
        };
        /**
         * Initializes this clock view.
         * @private
         * @return {?}
         */
        MatDatetimepickerClock.prototype._init = function () {
            this._hours.length = 0;
            this._minutes.length = 0;
            /** @type {?} */
            var hourNames = this._adapter.getHourNames();
            /** @type {?} */
            var minuteNames = this._adapter.getMinuteNames();
            if (this.twelvehour) {
                for (var i = 1; i < (hourNames.length / 2) + 1; i++) {
                    /** @type {?} */
                    var radian = i / 6 * Math.PI;
                    /** @type {?} */
                    var radius = CLOCK_OUTER_RADIUS;
                    /** @type {?} */
                    var date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), i + 1, 0);
                    /** @type {?} */
                    var enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate) >= 0) &&
                        (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate) <= 0);
                    this._hours.push({
                        value: i,
                        displayValue: i === 0 ? "00" : hourNames[i],
                        enabled: enabled,
                        top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,
                        left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS
                    });
                }
            }
            else {
                for (var i = 0; i < hourNames.length; i++) {
                    /** @type {?} */
                    var radian = i / 6 * Math.PI;
                    /** @type {?} */
                    var outer = i > 0 && i < 13;
                    /** @type {?} */
                    var radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;
                    /** @type {?} */
                    var date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), i, 0);
                    /** @type {?} */
                    var enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate) >= 0) &&
                        (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate) <= 0) &&
                        (!this.dateFilter || this.dateFilter(date, MatDatetimepickerFilterType.HOUR));
                    this._hours.push({
                        value: i,
                        displayValue: i === 0 ? "00" : hourNames[i],
                        enabled: enabled,
                        top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,
                        left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS,
                        fontSize: i > 0 && i < 13 ? "" : "80%"
                    });
                }
            }
            for (var i = 0; i < minuteNames.length; i += 5) {
                /** @type {?} */
                var radian = i / 30 * Math.PI;
                /** @type {?} */
                var date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), this._adapter.getHour(this.activeDate), i);
                /** @type {?} */
                var enabled = (!this.minDate || this._adapter.compareDatetime(date, this.minDate) >= 0) &&
                    (!this.maxDate || this._adapter.compareDatetime(date, this.maxDate) <= 0) &&
                    (!this.dateFilter || this.dateFilter(date, MatDatetimepickerFilterType.MINUTE));
                this._minutes.push({
                    value: i,
                    displayValue: i === 0 ? "00" : minuteNames[i],
                    enabled: enabled,
                    top: CLOCK_RADIUS - Math.cos(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS,
                    left: CLOCK_RADIUS + Math.sin(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS
                });
            }
        };
        /**
         * Set Time
         * @private
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerClock.prototype.setTime = function (event) {
            /** @type {?} */
            var trigger = this._element.nativeElement;
            /** @type {?} */
            var triggerRect = trigger.getBoundingClientRect();
            /** @type {?} */
            var width = trigger.offsetWidth;
            /** @type {?} */
            var height = trigger.offsetHeight;
            /** @type {?} */
            var pageX = event.pageX !== undefined ? event.pageX : event.touches[0].pageX;
            /** @type {?} */
            var pageY = event.pageY !== undefined ? event.pageY : event.touches[0].pageY;
            /** @type {?} */
            var x = (width / 2) - (pageX - triggerRect.left - window.pageXOffset);
            /** @type {?} */
            var y = (height / 2) - (pageY - triggerRect.top - window.pageYOffset);
            /** @type {?} */
            var radian = Math.atan2(-x, y);
            /** @type {?} */
            var unit = Math.PI / (this._hourView ? 6 : (this.interval ? (30 / this.interval) : 30));
            /** @type {?} */
            var z = Math.sqrt(x * x + y * y);
            /** @type {?} */
            var outer = this._hourView && z > ((width * (CLOCK_OUTER_RADIUS / 100)) +
                (width * (CLOCK_INNER_RADIUS / 100))) / 2;
            if (radian < 0) {
                radian = Math.PI * 2 + radian;
            }
            /** @type {?} */
            var value = Math.round(radian / unit);
            /** @type {?} */
            var date;
            if (this._hourView) {
                if (this.twelvehour) {
                    value = value === 0 ? 12 : value;
                }
                else {
                    if (value === 12) {
                        value = 0;
                    }
                    value = outer ? (value === 0 ? 12 : value) : value === 0 ? 0 : value + 12;
                }
                date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), value, this._adapter.getMinute(this.activeDate));
            }
            else {
                if (this.interval) {
                    value *= this.interval;
                }
                if (value === 60) {
                    value = 0;
                }
                date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), this._adapter.getDate(this.activeDate), this._adapter.getHour(this.activeDate), value);
            }
            /** @type {?} */
            var clamped = this._adapter.clampDate(date, this.minDate, this.maxDate);
            if (date === clamped) {
                this._timeChanged = true;
                this.activeDate = clamped;
                this.activeDateChange.emit(this.activeDate);
            }
        };
        return MatDatetimepickerClock;
    }());
    MatDatetimepickerClock.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-clock",
                    template: "<div class=\"mat-datetimepicker-clock\">\r\n  <div class=\"mat-datetimepicker-clock-center\"></div>\r\n  <div [ngStyle]=\"_hand\" class=\"mat-datetimepicker-clock-hand\"></div>\r\n  <div [class.active]=\"_hourView\" class=\"mat-datetimepicker-clock-hours\">\r\n    <div *ngFor=\"let item of _hours\"\r\n         [class.mat-datetimepicker-clock-cell-disabled]=\"!item.enabled\"\r\n         [class.mat-datetimepicker-clock-cell-selected]=\"_selectedHour == item.value\"\r\n         [style.fontSize]=\"item.fontSize\"\r\n         [style.left]=\"item.left+'%'\"\r\n         [style.top]=\"item.top+'%'\"\r\n         class=\"mat-datetimepicker-clock-cell\">{{ item.displayValue }}</div>\r\n  </div>\r\n  <div [class.active]=\"!_hourView\" class=\"mat-datetimepicker-clock-minutes\">\r\n    <div *ngFor=\"let item of _minutes\"\r\n         [class.mat-datetimepicker-clock-cell-disabled]=\"!item.enabled\"\r\n         [class.mat-datetimepicker-clock-cell-selected]=\"_selectedMinute == item.value\"\r\n         [style.left]=\"item.left+'%'\"\r\n         [style.top]=\"item.top+'%'\"\r\n         class=\"mat-datetimepicker-clock-cell\">{{ item.displayValue }}</div>\r\n  </div>\r\n</div>\r\n",
                    host: {
                        "role": "clock",
                        "(mousedown)": "_handleMousedown($event)"
                    },
                    styles: [":host{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;box-sizing:border-box;display:block;font-size:14px;margin:8px;min-width:224px;position:relative;user-select:none}.mat-datetimepicker-clock{background-color:#e0e0e0;border-radius:50%;height:0;padding-top:100%;position:relative;width:100%}.mat-datetimepicker-clock-center{border-radius:50%;height:2%;left:50%;margin:-1%;position:absolute;top:50%;width:2%}.mat-datetimepicker-clock-hand{bottom:0;left:0;margin:0 auto;position:absolute;right:0;top:0;transform-origin:bottom;width:1px}.mat-datetimepicker-clock-hand:before{border-radius:50%;content:\"\";height:8px;left:-4px;position:absolute;top:-4px;width:8px}.mat-datetimepicker-clock-hours,.mat-datetimepicker-clock-minutes{height:100%;left:0;opacity:0;position:absolute;top:0;transform:scale(1.2);transition:.35s;visibility:hidden;width:100%}.mat-datetimepicker-clock-hours.active,.mat-datetimepicker-clock-minutes.active{opacity:1;transform:scale(1);visibility:visible}.mat-datetimepicker-clock-minutes{transform:scale(.8)}.mat-datetimepicker-clock-cell{align-items:center;border-radius:50%;box-sizing:border-box;color:rgba(0,0,0,.87);cursor:pointer;display:flex;height:14.1666%;justify-content:center;position:absolute;width:14.1666%}.mat-datetimepicker-clock-cell:not(.mat-datetimepicker-clock-cell-selected):not(.mat-datetimepicker-clock-cell-disabled):hover{background-color:rgba(0,0,0,.1)}.mat-datetimepicker-clock-cell.mat-datetimepicker-clock-cell-disabled{color:rgba(0,0,0,.38);pointer-events:none}.mat-datetimepicker-clock-cell.mat-datetimepicker-clock-cell-selected{color:#fff}"]
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerClock.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DatetimeAdapter }
    ]; };
    MatDatetimepickerClock.propDecorators = {
        _userSelection: [{ type: core.Output }],
        dateFilter: [{ type: core.Input }],
        interval: [{ type: core.Input }],
        twelvehour: [{ type: core.Input }],
        selectedChange: [{ type: core.Output }],
        activeDateChange: [{ type: core.Output }],
        activeDate: [{ type: core.Input }],
        selected: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }],
        startView: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerClock.prototype._userSelection;
        /**
         * A function used to filter which dates are selectable.
         * @type {?}
         */
        MatDatetimepickerClock.prototype.dateFilter;
        /** @type {?} */
        MatDatetimepickerClock.prototype.interval;
        /** @type {?} */
        MatDatetimepickerClock.prototype.twelvehour;
        /**
         * Emits when the currently selected date changes.
         * @type {?}
         */
        MatDatetimepickerClock.prototype.selectedChange;
        /** @type {?} */
        MatDatetimepickerClock.prototype.activeDateChange;
        /**
         * Hours and Minutes representing the clock view.
         * @type {?}
         */
        MatDatetimepickerClock.prototype._hours;
        /** @type {?} */
        MatDatetimepickerClock.prototype._minutes;
        /**
         * Whether the clock is in hour view.
         * @type {?}
         */
        MatDatetimepickerClock.prototype._hourView;
        /** @type {?} */
        MatDatetimepickerClock.prototype._selectedHour;
        /** @type {?} */
        MatDatetimepickerClock.prototype._selectedMinute;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._timeChanged;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype.mouseMoveListener;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype.mouseUpListener;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._activeDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._selected;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._minDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._maxDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._element;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerClock.prototype._adapter;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Used to generate a unique ID for each datepicker instance.
     * @type {?}
     */
    var datetimepickerUid = 0;
    /**
     * Component used as the content for the datepicker dialog and popup. We use this instead of using
     * MatCalendar directly as the content so we can control the initial focus. This also gives us a
     * place to put additional features of the popup that are not part of the calendar itself in the
     * future. (e.g. confirmation buttons).
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerContent = /** @class */ (function () {
        function MatDatetimepickerContent() {
        }
        /**
         * @return {?}
         */
        MatDatetimepickerContent.prototype.ngAfterContentInit = function () {
            this._calendar._focusActiveCell();
        };
        /**
         * Handles keydown event on datepicker content.
         * @param {?} event The event.
         * @return {?}
         */
        MatDatetimepickerContent.prototype._handleKeydown = function (event) {
            // tslint:disable-next-line:deprecation
            if (event.keyCode === keycodes.ESCAPE) {
                this.datetimepicker.close();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        return MatDatetimepickerContent;
    }());
    MatDatetimepickerContent.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-content",
                    template: "<mat-datetimepicker-calendar (_userSelection)=\"datetimepicker.close()\" (selectedChange)=\"datetimepicker._select($event)\"\r\n                             (viewChanged)=\"datetimepicker._viewChanged($event)\"\r\n                             [ariaNextMonthLabel]=\"datetimepicker.ariaNextMonthLabel\"\r\n                             [ariaNextYearLabel]=\"datetimepicker.ariaNextYearLabel\"\r\n                             [ariaPrevMonthLabel]=\"datetimepicker.ariaPrevMonthLabel\"\r\n                             [ariaPrevYearLabel]=\"datetimepicker.ariaPrevYearLabel\"\r\n                             [attr.mode]=\"datetimepicker.mode\"\r\n                             [dateFilter]=\"datetimepicker._dateFilter\"\r\n                             [id]=\"datetimepicker.id\"\r\n                             [maxDate]=\"datetimepicker._maxDate\"\r\n                             [minDate]=\"datetimepicker._minDate\"\r\n                             [multiYearSelector]=\"datetimepicker.multiYearSelector\"\r\n                             [selected]=\"datetimepicker._selected\"\r\n                             [startAt]=\"datetimepicker.startAt\"\r\n                             [startView]=\"datetimepicker.startView\"\r\n                             [timeInterval]=\"datetimepicker.timeInterval\"\r\n                             [twelvehour]=\"datetimepicker.twelvehour\"\r\n                             [type]=\"datetimepicker.type\"\r\n                             cdkTrapFocus\r\n                             class=\"mat-typography\">\r\n</mat-datetimepicker-calendar>\r\n",
                    host: {
                        "class": "mat-datetimepicker-content",
                        "[class.mat-datetimepicker-content-touch]": "datetimepicker?.touchUi",
                        "(keydown)": "_handleKeydown($event)"
                    },
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".mat-datetimepicker-content{background-color:#fff;border-radius:2px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block;overflow:hidden}.mat-datetimepicker-calendar{height:405px;width:296px}.mat-datetimepicker-calendar[mode=landscape]{height:328px;width:446px}@media (min-width:480px){.mat-datetimepicker-calendar[mode=auto]{height:328px;width:446px}}.mat-datetimepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block}.cdk-global-overlay-wrapper,.cdk-overlay-container{height:100%;left:0;pointer-events:none;top:0;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{box-sizing:border-box}.cdk-overlay-backdrop,.cdk-overlay-pane{pointer-events:auto;position:absolute;z-index:1000}.cdk-overlay-backdrop{bottom:0;left:0;opacity:0;right:0;top:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.6)}.mat-datetimepicker-dialog .mat-dialog-container{padding:0}"]
                }] }
    ];
    MatDatetimepickerContent.propDecorators = {
        _calendar: [{ type: core.ViewChild, args: [MatDatetimepickerCalendar, { static: true },] }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerContent.prototype.datetimepicker;
        /** @type {?} */
        MatDatetimepickerContent.prototype._calendar;
    }
    /**
     * @template D
     */
    var MatDatetimepicker = /** @class */ (function () {
        /**
         * @param {?} _dialog
         * @param {?} _overlay
         * @param {?} _ngZone
         * @param {?} _viewContainerRef
         * @param {?} _scrollStrategy
         * @param {?} _dateAdapter
         * @param {?} _dir
         * @param {?} _document
         */
        function MatDatetimepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {
            this._dialog = _dialog;
            this._overlay = _overlay;
            this._ngZone = _ngZone;
            this._viewContainerRef = _viewContainerRef;
            this._scrollStrategy = _scrollStrategy;
            this._dateAdapter = _dateAdapter;
            this._dir = _dir;
            this._document = _document;
            /**
             * Active multi year view when click on year.
             */
            this.multiYearSelector = false;
            /**
             * if true change the clock to 12 hour format.
             */
            this.twelvehour = false;
            /**
             * The view that the calendar should start in.
             */
            this.startView = "month";
            this.mode = "auto";
            this.timeInterval = 1;
            this.ariaNextMonthLabel = "Next month";
            this.ariaPrevMonthLabel = "Previous month";
            this.ariaNextYearLabel = "Next year";
            this.ariaPrevYearLabel = "Previous year";
            /**
             * Emits new selected date when selected date changes.
             * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.
             */
            this.selectedChanged = new core.EventEmitter();
            /**
             * Emits when the datepicker has been opened.
             */
            // tslint:disable-next-line:no-output-rename
            this.openedStream = new core.EventEmitter();
            /**
             * Emits when the datepicker has been closed.
             */
            // tslint:disable-next-line:no-output-rename
            this.closedStream = new core.EventEmitter();
            /**
             * Emits when the view has been changed. *
             */
            this.viewChanged = new core.EventEmitter();
            /**
             * Whether the calendar is open.
             */
            this.opened = false;
            /**
             * The id for the datepicker calendar.
             */
            this.id = "mat-datetimepicker-" + datetimepickerUid++;
            /**
             * Emits when the datepicker is disabled.
             */
            this._disabledChange = new rxjs.Subject();
            this._validSelected = null;
            /**
             * The element that was focused before the datepicker was opened.
             */
            this._focusedElementBeforeOpen = null;
            this._inputSubscription = rxjs.Subscription.EMPTY;
            this._type = "date";
            this._touchUi = false;
            if (!this._dateAdapter) {
                throw createMissingDateImplError("DateAdapter");
            }
        }
        Object.defineProperty(MatDatetimepicker.prototype, "startAt", {
            /**
             * The date to open the calendar to initially.
             * @return {?}
             */
            get: function () {
                // If an explicit startAt is set we start there, otherwise we start at whatever the currently
                // selected value is.
                return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
            },
            /**
             * @param {?} date
             * @return {?}
             */
            set: function (date) {
                this._startAt = this._dateAdapter.getValidDateOrNull(date);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "openOnFocus", {
            /**
             * @return {?}
             */
            get: function () {
                return this._openOnFocus;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._openOnFocus = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "type", {
            /**
             * @return {?}
             */
            get: function () {
                return this._type;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._type = value || "date";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "touchUi", {
            /**
             * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
             * than a popup and elements have more padding to allow for bigger touch targets.
             * @return {?}
             */
            get: function () {
                return this._touchUi;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._touchUi = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "disabled", {
            /**
             * Whether the datepicker pop-up should be disabled.
             * @return {?}
             */
            get: function () {
                return this._disabled === undefined && this._datepickerInput ?
                    this._datepickerInput.disabled : !!this._disabled;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._disabledChange.next(newValue);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "_selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._validSelected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._validSelected = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "_minDate", {
            /**
             * The minimum selectable date.
             * @return {?}
             */
            get: function () {
                return this._datepickerInput && this._datepickerInput.min;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "_maxDate", {
            /**
             * The maximum selectable date.
             * @return {?}
             */
            get: function () {
                return this._datepickerInput && this._datepickerInput.max;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepicker.prototype, "_dateFilter", {
            /**
             * @return {?}
             */
            get: function () {
                return this._datepickerInput && this._datepickerInput._dateFilter;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepicker.prototype._handleFocus = function () {
            if (!this.opened && this.openOnFocus) {
                this.open();
            }
        };
        /**
         * @param {?} type
         * @return {?}
         */
        MatDatetimepicker.prototype._viewChanged = function (type) {
            this.viewChanged.emit(type);
        };
        /**
         * @return {?}
         */
        MatDatetimepicker.prototype.ngOnDestroy = function () {
            this.close();
            this._inputSubscription.unsubscribe();
            this._disabledChange.complete();
            if (this._popupRef) {
                this._popupRef.dispose();
            }
        };
        /**
         * Selects the given date
         * @param {?} date
         * @return {?}
         */
        MatDatetimepicker.prototype._select = function (date) {
            /** @type {?} */
            var oldValue = this._selected;
            this._selected = date;
            if (!this._dateAdapter.sameDatetime(oldValue, this._selected)) {
                // tslint:disable-next-line deprecation
                this.selectedChanged.emit(date);
            }
        };
        /**
         * Register an input with this datepicker.
         * @param {?} input The datepicker input to register with this datepicker.
         * @return {?}
         */
        MatDatetimepicker.prototype._registerInput = function (input) {
            var _this = this;
            if (this._datepickerInput) {
                throw Error("A MatDatepicker can only be associated with a single input.");
            }
            this._datepickerInput = input;
            this._inputSubscription =
                this._datepickerInput._valueChange.subscribe(( /**
                 * @param {?} value
                 * @return {?}
                 */function (value) { return _this._selected = value; }));
        };
        /**
         * Open the calendar.
         * @return {?}
         */
        MatDatetimepicker.prototype.open = function () {
            if (this.opened || this.disabled) {
                return;
            }
            if (!this._datepickerInput) {
                throw Error("Attempted to open an MatDatepicker with no associated input.");
            }
            if (this._document) {
                this._focusedElementBeforeOpen = this._document.activeElement;
            }
            this.touchUi ? this._openAsDialog() : this._openAsPopup();
            this.opened = true;
            this.openedStream.emit();
        };
        /**
         * Close the calendar.
         * @return {?}
         */
        MatDatetimepicker.prototype.close = function () {
            var _this = this;
            if (!this.opened) {
                return;
            }
            if (this._popupRef && this._popupRef.hasAttached()) {
                this._popupRef.detach();
            }
            if (this._dialogRef) {
                this._dialogRef.close();
                this._dialogRef = null;
            }
            if (this._calendarPortal && this._calendarPortal.isAttached) {
                this._calendarPortal.detach();
            }
            /** @type {?} */
            var completeClose = ( /**
             * @return {?}
             */function () {
                // The `_opened` could've been reset already if
                // we got two events in quick succession.
                if (_this.opened) {
                    _this.opened = false;
                    _this.closedStream.emit();
                    _this._focusedElementBeforeOpen = null;
                }
            });
            if (this._focusedElementBeforeOpen &&
                typeof this._focusedElementBeforeOpen.focus === "function") {
                // Because IE moves focus asynchronously, we can't count on it being restored before we've
                // marked the datepicker as closed. If the event fires out of sequence and the element that
                // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                // able to close the calendar at all. We work around it by making the logic, that marks
                // the datepicker as closed, async as well.
                this._focusedElementBeforeOpen.focus();
                setTimeout(completeClose);
            }
            else {
                completeClose();
            }
        };
        /**
         * Open the calendar as a dialog.
         * @private
         * @return {?}
         */
        MatDatetimepicker.prototype._openAsDialog = function () {
            var _this = this;
            this._dialogRef = this._dialog.open(MatDatetimepickerContent, {
                direction: this._dir ? this._dir.value : "ltr",
                viewContainerRef: this._viewContainerRef,
                panelClass: "mat-datetimepicker-dialog"
            });
            this._dialogRef.afterClosed().subscribe(( /**
             * @return {?}
             */function () { return _this.close(); }));
            this._dialogRef.componentInstance.datetimepicker = this;
        };
        /**
         * Open the calendar as a popup.
         * @private
         * @return {?}
         */
        MatDatetimepicker.prototype._openAsPopup = function () {
            var _this = this;
            if (!this._calendarPortal) {
                this._calendarPortal = new portal.ComponentPortal(MatDatetimepickerContent, this._viewContainerRef);
            }
            if (!this._popupRef) {
                this._createPopup();
            }
            if (!this._popupRef.hasAttached()) {
                /** @type {?} */
                var componentRef = this._popupRef.attach(this._calendarPortal);
                componentRef.instance.datetimepicker = this;
                // Update the position once the calendar has rendered.
                this._ngZone.onStable.asObservable().pipe(operators.first()).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this._popupRef.updatePosition();
                }));
            }
            this._popupRef.backdropClick().subscribe(( /**
             * @return {?}
             */function () { return _this.close(); }));
        };
        /**
         * Create the popup.
         * @private
         * @return {?}
         */
        MatDatetimepicker.prototype._createPopup = function () {
            /** @type {?} */
            var overlayConfig = new overlay.OverlayConfig({
                positionStrategy: this._createPopupPositionStrategy(),
                hasBackdrop: true,
                backdropClass: "mat-overlay-transparent-backdrop",
                direction: this._dir ? this._dir.value : "ltr",
                scrollStrategy: this._scrollStrategy(),
                panelClass: "mat-datetimepicker-popup"
            });
            this._popupRef = this._overlay.create(overlayConfig);
        };
        /**
         * Create the popup PositionStrategy.
         * @private
         * @return {?}
         */
        MatDatetimepicker.prototype._createPopupPositionStrategy = function () {
            return this._overlay.position()
                .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                .withTransformOriginOn(".mat-datetimepicker-content")
                .withFlexibleDimensions(false)
                .withViewportMargin(8)
                .withLockedPosition()
                .withPositions([
                {
                    originX: "start",
                    originY: "bottom",
                    overlayX: "start",
                    overlayY: "top"
                },
                {
                    originX: "start",
                    originY: "top",
                    overlayX: "start",
                    overlayY: "bottom"
                },
                {
                    originX: "end",
                    originY: "bottom",
                    overlayX: "end",
                    overlayY: "top"
                },
                {
                    originX: "end",
                    originY: "top",
                    overlayX: "end",
                    overlayY: "bottom"
                }
            ]);
        };
        return MatDatetimepicker;
    }());
    MatDatetimepicker.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker",
                    exportAs: "matDatetimepicker",
                    template: "",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    preserveWhitespaces: false
                }] }
    ];
    /** @nocollapse */
    MatDatetimepicker.ctorParameters = function () { return [
        { type: dialog.MatDialog },
        { type: overlay.Overlay },
        { type: core.NgZone },
        { type: core.ViewContainerRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [datepicker.MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    MatDatetimepicker.propDecorators = {
        multiYearSelector: [{ type: core.Input }],
        twelvehour: [{ type: core.Input }],
        startView: [{ type: core.Input }],
        mode: [{ type: core.Input }],
        timeInterval: [{ type: core.Input }],
        ariaNextMonthLabel: [{ type: core.Input }],
        ariaPrevMonthLabel: [{ type: core.Input }],
        ariaNextYearLabel: [{ type: core.Input }],
        ariaPrevYearLabel: [{ type: core.Input }],
        selectedChanged: [{ type: core.Output }],
        panelClass: [{ type: core.Input }],
        openedStream: [{ type: core.Output, args: ["opened",] }],
        closedStream: [{ type: core.Output, args: ["closed",] }],
        viewChanged: [{ type: core.Output }],
        startAt: [{ type: core.Input }],
        openOnFocus: [{ type: core.Input }],
        type: [{ type: core.Input }],
        touchUi: [{ type: core.Input }],
        disabled: [{ type: core.Input }]
    };
    if (false) {
        /**
         * Active multi year view when click on year.
         * @type {?}
         */
        MatDatetimepicker.prototype.multiYearSelector;
        /**
         * if true change the clock to 12 hour format.
         * @type {?}
         */
        MatDatetimepicker.prototype.twelvehour;
        /**
         * The view that the calendar should start in.
         * @type {?}
         */
        MatDatetimepicker.prototype.startView;
        /** @type {?} */
        MatDatetimepicker.prototype.mode;
        /** @type {?} */
        MatDatetimepicker.prototype.timeInterval;
        /** @type {?} */
        MatDatetimepicker.prototype.ariaNextMonthLabel;
        /** @type {?} */
        MatDatetimepicker.prototype.ariaPrevMonthLabel;
        /** @type {?} */
        MatDatetimepicker.prototype.ariaNextYearLabel;
        /** @type {?} */
        MatDatetimepicker.prototype.ariaPrevYearLabel;
        /**
         * Emits new selected date when selected date changes.
         * @deprecated Switch to the `dateChange` and `dateInput` binding on the input element.
         * @type {?}
         */
        MatDatetimepicker.prototype.selectedChanged;
        /**
         * Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`.
         * @type {?}
         */
        MatDatetimepicker.prototype.panelClass;
        /**
         * Emits when the datepicker has been opened.
         * @type {?}
         */
        MatDatetimepicker.prototype.openedStream;
        /**
         * Emits when the datepicker has been closed.
         * @type {?}
         */
        MatDatetimepicker.prototype.closedStream;
        /**
         * Emits when the view has been changed. *
         * @type {?}
         */
        MatDatetimepicker.prototype.viewChanged;
        /**
         * Whether the calendar is open.
         * @type {?}
         */
        MatDatetimepicker.prototype.opened;
        /**
         * The id for the datepicker calendar.
         * @type {?}
         */
        MatDatetimepicker.prototype.id;
        /**
         * The input element this datepicker is associated with.
         * @type {?}
         */
        MatDatetimepicker.prototype._datepickerInput;
        /**
         * Emits when the datepicker is disabled.
         * @type {?}
         */
        MatDatetimepicker.prototype._disabledChange;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._validSelected;
        /**
         * A reference to the overlay when the calendar is opened as a popup.
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._popupRef;
        /**
         * A reference to the dialog when the calendar is opened as a dialog.
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._dialogRef;
        /**
         * A portal containing the calendar for this datepicker.
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._calendarPortal;
        /**
         * The element that was focused before the datepicker was opened.
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._focusedElementBeforeOpen;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._inputSubscription;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._startAt;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._openOnFocus;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._type;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._touchUi;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._disabled;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._dialog;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._overlay;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._scrollStrategy;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._dateAdapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._dir;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepicker.prototype._document;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker-input.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable no-use-before-declare
    /** @type {?} */
    var MAT_DATETIMEPICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return MatDatetimepickerInput; })),
        multi: true
    };
    /** @type {?} */
    var MAT_DATETIMEPICKER_VALIDATORS = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return MatDatetimepickerInput; })),
        multi: true
    };
    /**
     * An event used for datepicker input and change events. We don't always have access to a native
     * input or change event because the event may have been triggered by the user clicking on the
     * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
     * @template D
     */
    var MatDatetimepickerInputEvent = /** @class */ (function () {
        /**
         * @param {?} target
         * @param {?} targetElement
         */
        function MatDatetimepickerInputEvent(target, targetElement) {
            this.target = target;
            this.targetElement = targetElement;
            this.value = this.target.value;
        }
        return MatDatetimepickerInputEvent;
    }());
    if (false) {
        /**
         * The new value for the target datepicker input.
         * @type {?}
         */
        MatDatetimepickerInputEvent.prototype.value;
        /** @type {?} */
        MatDatetimepickerInputEvent.prototype.target;
        /** @type {?} */
        MatDatetimepickerInputEvent.prototype.targetElement;
    }
    /**
     * Directive used to connect an input to a MatDatepicker.
     * @template D
     */
    var MatDatetimepickerInput = /** @class */ (function () {
        /**
         * @param {?} _elementRef
         * @param {?} _dateAdapter
         * @param {?} _dateFormats
         * @param {?} _formField
         */
        function MatDatetimepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
            var _this = this;
            this._elementRef = _elementRef;
            this._dateAdapter = _dateAdapter;
            this._dateFormats = _dateFormats;
            this._formField = _formField;
            /**
             * Emits when a `change` event is fired on this `<input>`.
             */
            this.dateChange = new core.EventEmitter();
            /**
             * Emits when an `input` event is fired on this `<input>`.
             */
            this.dateInput = new core.EventEmitter();
            /**
             * Emits when the value changes (either due to user input or programmatic change).
             */
            this._valueChange = new core.EventEmitter();
            /**
             * Emits when the disabled state has changed
             */
            this._disabledChange = new core.EventEmitter();
            this._datepickerSubscription = rxjs.Subscription.EMPTY;
            this._localeSubscription = rxjs.Subscription.EMPTY;
            /**
             * Whether the last value set on the input was valid.
             */
            this._lastValueValid = false;
            this._onTouched = ( /**
             * @return {?}
             */function () {
            });
            this._cvaOnChange = ( /**
             * @return {?}
             */function () {
            });
            this._validatorOnChange = ( /**
             * @return {?}
             */function () {
            });
            /**
             * The form control validator for whether the input parses.
             */
            this._parseValidator = ( /**
             * @return {?}
             */function () {
                return _this._lastValueValid ?
                    null : { "matDatepickerParse": { "text": _this._elementRef.nativeElement.value } };
            });
            /**
             * The form control validator for the min date.
             */
            this._minValidator = ( /**
             * @param {?} control
             * @return {?}
             */function (control) {
                /** @type {?} */
                var controlValue = _this._dateAdapter.getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return (!_this.min || !controlValue ||
                    _this._dateAdapter.compareDatetime(_this.min, controlValue) <= 0) ?
                    null : { "matDatepickerMin": { "min": _this.min, "actual": controlValue } };
            });
            /**
             * The form control validator for the max date.
             */
            this._maxValidator = ( /**
             * @param {?} control
             * @return {?}
             */function (control) {
                /** @type {?} */
                var controlValue = _this._dateAdapter.getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return (!_this.max || !controlValue ||
                    _this._dateAdapter.compareDatetime(_this.max, controlValue) >= 0) ?
                    null : { "matDatepickerMax": { "max": _this.max, "actual": controlValue } };
            });
            /**
             * The form control validator for the date filter.
             */
            this._filterValidator = ( /**
             * @param {?} control
             * @return {?}
             */function (control) {
                /** @type {?} */
                var controlValue = _this._dateAdapter.getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue, MatDatetimepickerFilterType.DATE) ?
                    null : { "matDatepickerFilter": true };
            });
            /**
             * The combined form control validator for this input.
             */
            this._validator = forms.Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
            if (!this._dateAdapter) {
                throw createMissingDateImplError("DatetimeAdapter");
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError("MAT_DATETIME_FORMATS");
            }
            // Update the displayed date when the locale changes.
            this._localeSubscription = _dateAdapter.localeChanges.subscribe(( /**
             * @return {?}
             */function () {
                _this.value = _this.value;
            }));
        }
        Object.defineProperty(MatDatetimepickerInput.prototype, "matDatetimepicker", {
            /**
             * The datepicker that this input is associated with.
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this.registerDatepicker(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerInput.prototype, "matDatepickerFilter", {
            /**
             * @param {?} filter
             * @return {?}
             */
            set: function (filter) {
                this._dateFilter = filter;
                this._validatorOnChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerInput.prototype, "value", {
            /**
             * The value of the input.
             * @return {?}
             */
            get: function () {
                return this._value;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                var _this = this;
                value = this._dateAdapter.deserialize(value);
                this._lastValueValid = !value || this._dateAdapter.isValid(value);
                value = this._dateAdapter.getValidDateOrNull(value);
                /** @type {?} */
                var oldDate = this.value;
                this._value = value;
                this._formatValue(value);
                // use timeout to ensure the datetimepicker is instantiated and we get the correct format
                setTimeout(( /**
                 * @return {?}
                 */function () {
                    if (!_this._dateAdapter.sameDatetime(oldDate, value)) {
                        _this._valueChange.emit(value);
                    }
                }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerInput.prototype, "min", {
            /**
             * The minimum valid date.
             * @return {?}
             */
            get: function () {
                return this._min;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._min = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._validatorOnChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerInput.prototype, "max", {
            /**
             * The maximum valid date.
             * @return {?}
             */
            get: function () {
                return this._max;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._max = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._validatorOnChange();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerInput.prototype, "disabled", {
            /**
             * Whether the datepicker-input is disabled.
             * @return {?}
             */
            get: function () {
                return !!this._disabled;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._disabledChange.emit(newValue);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerInput.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this._datepicker) {
                // tslint:disable-next-line deprecation
                this._datepickerSubscription = this._datepicker.selectedChanged.subscribe(( /**
                 * @param {?} selected
                 * @return {?}
                 */function (selected) {
                    _this.value = selected;
                    _this._cvaOnChange(selected);
                    _this._onTouched();
                    _this.dateInput.emit(new MatDatetimepickerInputEvent(_this, _this._elementRef.nativeElement));
                    _this.dateChange.emit(new MatDatetimepickerInputEvent(_this, _this._elementRef.nativeElement));
                }));
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerInput.prototype.ngOnDestroy = function () {
            this._datepickerSubscription.unsubscribe();
            this._localeSubscription.unsubscribe();
            this._valueChange.complete();
            this._disabledChange.complete();
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MatDatetimepickerInput.prototype.registerOnValidatorChange = function (fn) {
            this._validatorOnChange = fn;
        };
        /**
         * @param {?} c
         * @return {?}
         */
        MatDatetimepickerInput.prototype.validate = function (c) {
            return this._validator ? this._validator(c) : null;
        };
        /**
         * Gets the element that the datepicker popup should be connected to.
         * @return {?} The element to connect the popup to.
         */
        MatDatetimepickerInput.prototype.getConnectedOverlayOrigin = function () {
            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
        };
        // Implemented as part of ControlValueAccessor
        /**
         * @param {?} value
         * @return {?}
         */
        MatDatetimepickerInput.prototype.writeValue = function (value) {
            this.value = value;
        };
        // Implemented as part of ControlValueAccessor
        /**
         * @param {?} fn
         * @return {?}
         */
        MatDatetimepickerInput.prototype.registerOnChange = function (fn) {
            this._cvaOnChange = fn;
        };
        // Implemented as part of ControlValueAccessor
        /**
         * @param {?} fn
         * @return {?}
         */
        MatDatetimepickerInput.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        // Implemented as part of ControlValueAccessor
        /**
         * @param {?} disabled
         * @return {?}
         */
        MatDatetimepickerInput.prototype.setDisabledState = function (disabled) {
            this.disabled = disabled;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerInput.prototype._onKeydown = function (event) {
            // tslint:disable-next-line:deprecation
            if (event.altKey && event.keyCode === keycodes.DOWN_ARROW) {
                this._datepicker.open();
                event.preventDefault();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MatDatetimepickerInput.prototype._onInput = function (value) {
            /** @type {?} */
            var date = this._dateAdapter.parse(value, this.getParseFormat());
            this._lastValueValid = !date || this._dateAdapter.isValid(date);
            date = this._dateAdapter.getValidDateOrNull(date);
            this._value = date;
            this._cvaOnChange(date);
            this._valueChange.emit(date);
            this.dateInput.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));
        };
        /**
         * @return {?}
         */
        MatDatetimepickerInput.prototype._onChange = function () {
            this.dateChange.emit(new MatDatetimepickerInputEvent(this, this._elementRef.nativeElement));
        };
        /**
         * Handles blur events on the input.
         * @return {?}
         */
        MatDatetimepickerInput.prototype._onBlur = function () {
            // Reformat the input only if we have a valid value.
            if (this.value) {
                this._formatValue(this.value);
            }
            this._onTouched();
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        MatDatetimepickerInput.prototype.registerDatepicker = function (value) {
            if (value) {
                this._datepicker = value;
                this._datepicker._registerInput(this);
            }
        };
        /**
         * @private
         * @return {?}
         */
        MatDatetimepickerInput.prototype.getDisplayFormat = function () {
            switch (this._datepicker.type) {
                case "date":
                    return this._dateFormats.display.dateInput;
                case "datetime":
                    return this._dateFormats.display.datetimeInput;
                case "time":
                    return this._dateFormats.display.timeInput;
                case "month":
                    return this._dateFormats.display.monthInput;
            }
        };
        /**
         * @private
         * @return {?}
         */
        MatDatetimepickerInput.prototype.getParseFormat = function () {
            /** @type {?} */
            var parseFormat;
            switch (this._datepicker.type) {
                case "date":
                    parseFormat = this._dateFormats.parse.dateInput;
                    break;
                case "datetime":
                    parseFormat = this._dateFormats.parse.datetimeInput;
                    break;
                case "time":
                    parseFormat = this._dateFormats.parse.timeInput;
                    break;
                case "month":
                    parseFormat = this._dateFormats.parse.monthInput;
                    break;
            }
            if (!parseFormat) {
                parseFormat = this._dateFormats.parse.dateInput;
            }
            return parseFormat;
        };
        /**
         * Formats a value and sets it on the input element.
         * @private
         * @param {?} value
         * @return {?}
         */
        MatDatetimepickerInput.prototype._formatValue = function (value) {
            this._elementRef.nativeElement.value =
                value ? this._dateAdapter.format(value, this.getDisplayFormat()) : "";
        };
        return MatDatetimepickerInput;
    }());
    MatDatetimepickerInput.decorators = [
        { type: core.Directive, args: [{
                    selector: "input[matDatetimepicker]",
                    providers: [
                        MAT_DATETIMEPICKER_VALUE_ACCESSOR,
                        MAT_DATETIMEPICKER_VALIDATORS,
                        { provide: input.MAT_INPUT_VALUE_ACCESSOR, useExisting: MatDatetimepickerInput },
                    ],
                    host: {
                        "[attr.aria-haspopup]": "true",
                        "[attr.aria-owns]": "(_datepicker?.opened && _datepicker.id) || null",
                        "[attr.min]": "min ? _dateAdapter.toIso8601(min) : null",
                        "[attr.max]": "max ? _dateAdapter.toIso8601(max) : null",
                        "[disabled]": "disabled",
                        "(focus)": "_datepicker._handleFocus()",
                        "(input)": "_onInput($event.target.value)",
                        "(change)": "_onChange()",
                        "(blur)": "_onBlur()",
                        "(keydown)": "_onKeydown($event)"
                    },
                    exportAs: "matDatepickerInput"
                },] }
    ];
    /** @nocollapse */
    MatDatetimepickerInput.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATETIME_FORMATS,] }] },
        { type: formField.MatFormField, decorators: [{ type: core.Optional }] }
    ]; };
    MatDatetimepickerInput.propDecorators = {
        dateChange: [{ type: core.Output }],
        dateInput: [{ type: core.Output }],
        matDatetimepicker: [{ type: core.Input }],
        matDatepickerFilter: [{ type: core.Input }],
        value: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        disabled: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerInput.prototype._datepicker;
        /** @type {?} */
        MatDatetimepickerInput.prototype._dateFilter;
        /**
         * Emits when a `change` event is fired on this `<input>`.
         * @type {?}
         */
        MatDatetimepickerInput.prototype.dateChange;
        /**
         * Emits when an `input` event is fired on this `<input>`.
         * @type {?}
         */
        MatDatetimepickerInput.prototype.dateInput;
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         * @type {?}
         */
        MatDatetimepickerInput.prototype._valueChange;
        /**
         * Emits when the disabled state has changed
         * @type {?}
         */
        MatDatetimepickerInput.prototype._disabledChange;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._datepickerSubscription;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._localeSubscription;
        /**
         * Whether the last value set on the input was valid.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._lastValueValid;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._value;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._min;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._max;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._disabled;
        /** @type {?} */
        MatDatetimepickerInput.prototype._onTouched;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._cvaOnChange;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._validatorOnChange;
        /**
         * The form control validator for whether the input parses.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._parseValidator;
        /**
         * The form control validator for the min date.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._minValidator;
        /**
         * The form control validator for the max date.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._maxValidator;
        /**
         * The form control validator for the date filter.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._filterValidator;
        /**
         * The combined form control validator for this input.
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._validator;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._elementRef;
        /** @type {?} */
        MatDatetimepickerInput.prototype._dateAdapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._dateFormats;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerInput.prototype._formField;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker-toggle.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template D
     */
    var MatDatetimepickerToggle = /** @class */ (function () {
        /**
         * @param {?} _intl
         * @param {?} _changeDetectorRef
         */
        function MatDatetimepickerToggle(_intl, _changeDetectorRef) {
            this._intl = _intl;
            this._changeDetectorRef = _changeDetectorRef;
            this._stateChanges = rxjs.Subscription.EMPTY;
        }
        Object.defineProperty(MatDatetimepickerToggle.prototype, "disabled", {
            /**
             * Whether the toggle button is disabled.
             * @return {?}
             */
            get: function () {
                return this._disabled === undefined ? this.datetimepicker.disabled : !!this._disabled;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        MatDatetimepickerToggle.prototype.ngOnChanges = function (changes) {
            if (changes.datepicker) {
                this._watchStateChanges();
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerToggle.prototype.ngOnDestroy = function () {
            this._stateChanges.unsubscribe();
        };
        /**
         * @return {?}
         */
        MatDatetimepickerToggle.prototype.ngAfterContentInit = function () {
            this._watchStateChanges();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MatDatetimepickerToggle.prototype._open = function (event) {
            if (this.datetimepicker && !this.disabled) {
                this.datetimepicker.open();
                event.stopPropagation();
            }
        };
        /**
         * @private
         * @return {?}
         */
        MatDatetimepickerToggle.prototype._watchStateChanges = function () {
            var _this = this;
            /** @type {?} */
            var datepickerDisabled = this.datetimepicker ? this.datetimepicker._disabledChange : rxjs.of();
            /** @type {?} */
            var inputDisabled = this.datetimepicker && this.datetimepicker._datepickerInput ?
                this.datetimepicker._datepickerInput._disabledChange : rxjs.of();
            this._stateChanges.unsubscribe();
            this._stateChanges = rxjs.merge(this._intl.changes, datepickerDisabled, inputDisabled)
                .subscribe(( /**
         * @return {?}
         */function () { return _this._changeDetectorRef.markForCheck(); }));
        };
        return MatDatetimepickerToggle;
    }());
    MatDatetimepickerToggle.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-toggle",
                    template: "<button (click)=\"_open($event)\" [attr.aria-label]=\"_intl.openCalendarLabel\" [disabled]=\"disabled\"\r\n        mat-icon-button type=\"button\">\r\n  <mat-icon [ngSwitch]=\"datetimepicker.type\">\r\n    <svg *ngSwitchCase=\"'time'\" fill=\"currentColor\" focusable=\"false\" height=\"100%\" style=\"vertical-align: top\"\r\n         viewBox=\"0 0 24 24\" width=\"100%\">\r\n      <path\r\n        d=\"M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\"></path>\r\n    </svg>\r\n    <svg *ngSwitchCase=\"'datetime'\" fill=\"currentColor\" focusable=\"false\" height=\"100%\" style=\"vertical-align: top\"\r\n         viewBox=\"0 0 24 24\" width=\"100%\">\r\n      <path\r\n        d=\"M15,13H16.5V15.82L18.94,17.23L18.19,18.53L15,16.69V13M19,8H5V19H9.67C9.24,18.09 9,17.07 9,16A7,7 0 0,1 16,9C17.07,9 18.09,9.24 19,9.67V8M5,21C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H6V1H8V3H16V1H18V3H19A2,2 0 0,1 21,5V11.1C22.24,12.36 23,14.09 23,16A7,7 0 0,1 16,23C14.09,23 12.36,22.24 11.1,21H5M16,11.15A4.85,4.85 0 0,0 11.15,16C11.15,18.68 13.32,20.85 16,20.85A4.85,4.85 0 0,0 20.85,16C20.85,13.32 18.68,11.15 16,11.15Z\"></path>\r\n    </svg>\r\n    <svg *ngSwitchDefault fill=\"currentColor\" focusable=\"false\" height=\"100%\" style=\"vertical-align: top\"\r\n         viewBox=\"0 0 24 24\" width=\"100%\">\r\n      <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\r\n      <path\r\n        d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/>\r\n    </svg>\r\n  </mat-icon>\r\n</button>\r\n",
                    host: {
                        "class": "mat-datetimepicker-toggle"
                    },
                    exportAs: "matDatetimepickerToggle",
                    encapsulation: core.ViewEncapsulation.None,
                    preserveWhitespaces: false,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerToggle.ctorParameters = function () { return [
        { type: datepicker.MatDatepickerIntl },
        { type: core.ChangeDetectorRef }
    ]; };
    MatDatetimepickerToggle.propDecorators = {
        datetimepicker: [{ type: core.Input, args: ["for",] }],
        disabled: [{ type: core.Input }]
    };
    if (false) {
        /**
         * Datepicker instance that the button will toggle.
         * @type {?}
         */
        MatDatetimepickerToggle.prototype.datetimepicker;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerToggle.prototype._stateChanges;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerToggle.prototype._disabled;
        /** @type {?} */
        MatDatetimepickerToggle.prototype._intl;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerToggle.prototype._changeDetectorRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/month-view.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DAYS_PER_WEEK = 7;
    /**
     * An internal component used to display a single month in the datepicker.
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerMonthView = /** @class */ (function () {
        /**
         * @param {?} _adapter
         * @param {?} _dateFormats
         */
        function MatDatetimepickerMonthView(_adapter, _dateFormats) {
            this._adapter = _adapter;
            this._dateFormats = _dateFormats;
            this.type = "date";
            this._userSelection = new core.EventEmitter();
            /**
             * Emits when a new date is selected.
             */
            this.selectedChange = new core.EventEmitter();
            if (!this._adapter) {
                throw createMissingDateImplError("DatetimeAdapter");
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError("MAT_DATETIME_FORMATS");
            }
            /** @type {?} */
            var firstDayOfWeek = this._adapter.getFirstDayOfWeek();
            /** @type {?} */
            var narrowWeekdays = this._adapter.getDayOfWeekNames("narrow");
            /** @type {?} */
            var longWeekdays = this._adapter.getDayOfWeekNames("long");
            // Rotate the labels for days of the week based on the configured first day of the week.
            /** @type {?} */
            var weekdays = longWeekdays.map(( /**
             * @param {?} long
             * @param {?} i
             * @return {?}
             */function (long, i) {
                return { long: long, narrow: narrowWeekdays[i] };
            }));
            this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
            this._activeDate = this._adapter.today();
        }
        Object.defineProperty(MatDatetimepickerMonthView.prototype, "activeDate", {
            /**
             * The date to display in this month view (everything other than the month and year is ignored).
             * @return {?}
             */
            get: function () {
                return this._activeDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var oldActiveDate = this._activeDate;
                this._activeDate = value || this._adapter.today();
                if (oldActiveDate && this._activeDate &&
                    !this._adapter.sameMonthAndYear(oldActiveDate, this._activeDate)) {
                    this._init();
                    if (this._adapter.isInNextMonth(oldActiveDate, this._activeDate)) {
                        this.calendarState("right");
                    }
                    else {
                        this.calendarState("left");
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerMonthView.prototype, "selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._selected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selected = value;
                this._selectedDate = this._getDateInCurrentMonth(this.selected);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /**
         * Handles when a new date is selected.
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype._dateSelected = function (date) {
            this.selectedChange.emit(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), date, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));
            if (this.type === "date") {
                this._userSelection.emit();
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype._calendarStateDone = function () {
            this._calendarState = "";
        };
        /**
         * Initializes this month view.
         * @private
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype._init = function () {
            this._selectedDate = this._getDateInCurrentMonth(this.selected);
            this._todayDate = this._getDateInCurrentMonth(this._adapter.today());
            /** @type {?} */
            var firstOfMonth = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate));
            this._firstWeekOffset =
                (DAYS_PER_WEEK + this._adapter.getDayOfWeek(firstOfMonth) -
                    this._adapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
            this._createWeekCells();
        };
        /**
         * Creates MdCalendarCells for the dates in this month.
         * @private
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype._createWeekCells = function () {
            /** @type {?} */
            var daysInMonth = this._adapter.getNumDaysInMonth(this.activeDate);
            /** @type {?} */
            var dateNames = this._adapter.getDateNames();
            this._weeks = [[]];
            for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                if (cell == DAYS_PER_WEEK) {
                    this._weeks.push([]);
                    cell = 0;
                }
                /** @type {?} */
                var date = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), this._adapter.getMonth(this.activeDate), i + 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate));
                /** @type {?} */
                var enabled = !this.dateFilter ||
                    this.dateFilter(date);
                /** @type {?} */
                var ariaLabel = this._adapter.format(date, this._dateFormats.display.dateA11yLabel);
                this._weeks[this._weeks.length - 1]
                    .push(new MatDatetimepickerCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));
            }
        };
        /**
         * Gets the date in this month that the given Date falls on.
         * Returns null if the given Date is in another month.
         * @private
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype._getDateInCurrentMonth = function (date) {
            return this._adapter.sameMonthAndYear(date, this.activeDate) ?
                this._adapter.getDate(date) : null;
        };
        /**
         * @private
         * @param {?} direction
         * @return {?}
         */
        MatDatetimepickerMonthView.prototype.calendarState = function (direction) {
            this._calendarState = direction;
        };
        return MatDatetimepickerMonthView;
    }());
    MatDatetimepickerMonthView.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-month-view",
                    template: "<table class=\"mat-datetimepicker-calendar-table\">\r\n  <thead class=\"mat-datetimepicker-calendar-table-header\">\r\n  <tr>\r\n    <th *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th>\r\n  </tr>\r\n  </thead>\r\n  <tbody (@slideCalendar.done)=\"_calendarStateDone()\"\r\n         (selectedValueChange)=\"_dateSelected($event)\"\r\n         [@slideCalendar]=\"_calendarState\"\r\n         [activeCell]=\"_adapter.getDate(activeDate) - 1\"\r\n         [rows]=\"_weeks\"\r\n         [selectedValue]=\"_selectedDate\"\r\n         [todayValue]=\"_todayDate\"\r\n         mat-datetimepicker-calendar-body\r\n         role=\"grid\"></tbody>\r\n</table>\r\n",
                    animations: [slideCalendar],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerMonthView.ctorParameters = function () { return [
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATETIME_FORMATS,] }] }
    ]; };
    MatDatetimepickerMonthView.propDecorators = {
        type: [{ type: core.Input }],
        _userSelection: [{ type: core.Output }],
        dateFilter: [{ type: core.Input }],
        selectedChange: [{ type: core.Output }],
        activeDate: [{ type: core.Input }],
        selected: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerMonthView.prototype.type;
        /** @type {?} */
        MatDatetimepickerMonthView.prototype._userSelection;
        /**
         * A function used to filter which dates are selectable.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype.dateFilter;
        /**
         * Emits when a new date is selected.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype.selectedChange;
        /**
         * Grid of calendar cells representing the dates of the month.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype._weeks;
        /**
         * The number of blank cells in the first row before the 1st of the month.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype._firstWeekOffset;
        /**
         * The date of the month that the currently selected Date falls on.
         * Null if the currently selected Date is in another month.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype._selectedDate;
        /**
         * The date of the month that today falls on. Null if today is in another month.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype._todayDate;
        /**
         * The names of the weekdays.
         * @type {?}
         */
        MatDatetimepickerMonthView.prototype._weekdays;
        /** @type {?} */
        MatDatetimepickerMonthView.prototype._calendarState;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMonthView.prototype._activeDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMonthView.prototype._selected;
        /** @type {?} */
        MatDatetimepickerMonthView.prototype._adapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerMonthView.prototype._dateFormats;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/year-view.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An internal component used to display a single year in the datepicker.
     * \@docs-private
     * @template D
     */
    var MatDatetimepickerYearView = /** @class */ (function () {
        /**
         * @param {?} _adapter
         * @param {?} _dateFormats
         */
        function MatDatetimepickerYearView(_adapter, _dateFormats) {
            this._adapter = _adapter;
            this._dateFormats = _dateFormats;
            this._userSelection = new core.EventEmitter();
            this.type = "date";
            /**
             * Emits when a new month is selected.
             */
            this.selectedChange = new core.EventEmitter();
            if (!this._adapter) {
                throw createMissingDateImplError("DatetimeAdapter");
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError("MAT_DATETIME_FORMATS");
            }
            this._activeDate = this._adapter.today();
        }
        Object.defineProperty(MatDatetimepickerYearView.prototype, "activeDate", {
            /**
             * The date to display in this year view (everything other than the year is ignored).
             * @return {?}
             */
            get: function () {
                return this._activeDate;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                /** @type {?} */
                var oldActiveDate = this._activeDate;
                this._activeDate = value || this._adapter.today();
                if (oldActiveDate && this._activeDate &&
                    !this._adapter.sameYear(oldActiveDate, this._activeDate)) {
                    this._init();
                    // if (oldActiveDate < this._activeDate) {
                    //  this.calendarState('right');
                    // } else {
                    //  this.calendarState('left');
                    // }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MatDatetimepickerYearView.prototype, "selected", {
            /**
             * The currently selected date.
             * @return {?}
             */
            get: function () {
                return this._selected;
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) {
                this._selected = value;
                this._selectedMonth = this._getMonthInCurrentYear(this.selected);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatDatetimepickerYearView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /**
         * Handles when a new month is selected.
         * @param {?} month
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._monthSelected = function (month) {
            /** @type {?} */
            var normalizedDate = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, 0, 0);
            this.selectedChange.emit(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, Math.min(this._adapter.getDate(this.activeDate), this._adapter.getNumDaysInMonth(normalizedDate)), this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)));
            if (this.type === "month") {
                this._userSelection.emit();
            }
        };
        /**
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._calendarStateDone = function () {
            this._calendarState = "";
        };
        /**
         * Initializes this month view.
         * @private
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._init = function () {
            var _this = this;
            this._selectedMonth = this._getMonthInCurrentYear(this.selected);
            this._todayMonth = this._getMonthInCurrentYear(this._adapter.today());
            this._yearLabel = this._adapter.getYearName(this.activeDate);
            /** @type {?} */
            var monthNames = this._adapter.getMonthNames("short");
            // First row of months only contains 5 elements so we can fit the year label on the same row.
            this._months = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11]].map(( /**
             * @param {?} row
             * @return {?}
             */function (/**
             * @param {?} row
             * @return {?}
             */ row) { return row.map(( /**
             * @param {?} month
             * @return {?}
             */function (/**
             * @param {?} month
             * @return {?}
             */ month) { return _this._createCellForMonth(month, monthNames[month]); })); }));
        };
        /**
         * Gets the month in this year that the given Date falls on.
         * Returns null if the given Date is in another year.
         * @private
         * @param {?} date
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._getMonthInCurrentYear = function (date) {
            return this._adapter.sameYear(date, this.activeDate) ?
                this._adapter.getMonth(date) : null;
        };
        /**
         * Creates an MdCalendarCell for the given month.
         * @private
         * @param {?} month
         * @param {?} monthName
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._createCellForMonth = function (month, monthName) {
            /** @type {?} */
            var ariaLabel = this._adapter.format(this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate)), this._dateFormats.display.monthYearA11yLabel);
            return new MatDatetimepickerCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._isMonthEnabled(month));
        };
        // private calendarState(direction: string): void {
        //   this._calendarState = direction;
        // }
        /**
         * Whether the given month is enabled.
         * @private
         * @param {?} month
         * @return {?}
         */
        MatDatetimepickerYearView.prototype._isMonthEnabled = function (month) {
            if (!this.dateFilter) {
                return true;
            }
            /** @type {?} */
            var firstOfMonth = this._adapter.createDatetime(this._adapter.getYear(this.activeDate), month, 1, this._adapter.getHour(this.activeDate), this._adapter.getMinute(this.activeDate));
            // If any date in the month is enabled count the month as enabled.
            for (var date = firstOfMonth; this._adapter.getMonth(date) == month; date = this._adapter.addCalendarDays(date, 1)) {
                if (this.dateFilter(date)) {
                    return true;
                }
            }
            return false;
        };
        return MatDatetimepickerYearView;
    }());
    MatDatetimepickerYearView.decorators = [
        { type: core.Component, args: [{
                    selector: "mat-datetimepicker-year-view",
                    template: "<table class=\"mat-datetimepicker-calendar-table\">\r\n  <thead class=\"mat-datetimepicker-calendar-table-header\"></thead>\r\n  <tbody (@slideCalendar.done)=\"_calendarStateDone()\"\r\n         (selectedValueChange)=\"_monthSelected($event)\"\r\n         [@slideCalendar]=\"_calendarState\"\r\n         [activeCell]=\"_adapter.getMonth(activeDate)\"\r\n         [labelMinRequiredCells]=\"2\"\r\n         [label]=\"_yearLabel\"\r\n         [rows]=\"_months\"\r\n         [selectedValue]=\"_selectedMonth\"\r\n         [todayValue]=\"_todayMonth\"\r\n         allowDisabledSelection=\"true\"\r\n         mat-datetimepicker-calendar-body\r\n         role=\"grid\"></tbody>\r\n</table>\r\n",
                    animations: [slideCalendar],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    MatDatetimepickerYearView.ctorParameters = function () { return [
        { type: DatetimeAdapter, decorators: [{ type: core.Optional }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATETIME_FORMATS,] }] }
    ]; };
    MatDatetimepickerYearView.propDecorators = {
        _userSelection: [{ type: core.Output }],
        type: [{ type: core.Input }],
        dateFilter: [{ type: core.Input }],
        selectedChange: [{ type: core.Output }],
        activeDate: [{ type: core.Input }],
        selected: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        MatDatetimepickerYearView.prototype._userSelection;
        /** @type {?} */
        MatDatetimepickerYearView.prototype.type;
        /**
         * A function used to filter which dates are selectable.
         * @type {?}
         */
        MatDatetimepickerYearView.prototype.dateFilter;
        /**
         * Emits when a new month is selected.
         * @type {?}
         */
        MatDatetimepickerYearView.prototype.selectedChange;
        /**
         * Grid of calendar cells representing the months of the year.
         * @type {?}
         */
        MatDatetimepickerYearView.prototype._months;
        /**
         * The label for this year (e.g. "2017").
         * @type {?}
         */
        MatDatetimepickerYearView.prototype._yearLabel;
        /**
         * The month in this year that today falls on. Null if today is in a different year.
         * @type {?}
         */
        MatDatetimepickerYearView.prototype._todayMonth;
        /**
         * The month in this year that the selected Date falls on.
         * Null if the selected Date is in a different year.
         * @type {?}
         */
        MatDatetimepickerYearView.prototype._selectedMonth;
        /** @type {?} */
        MatDatetimepickerYearView.prototype._calendarState;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerYearView.prototype._activeDate;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerYearView.prototype._selected;
        /** @type {?} */
        MatDatetimepickerYearView.prototype._adapter;
        /**
         * @type {?}
         * @private
         */
        MatDatetimepickerYearView.prototype._dateFormats;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/datetimepicker.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MatDatetimepickerModule = /** @class */ (function () {
        function MatDatetimepickerModule() {
        }
        return MatDatetimepickerModule;
    }());
    MatDatetimepickerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        button.MatButtonModule,
                        dialog.MatDialogModule,
                        icon.MatIconModule,
                        overlay.OverlayModule,
                        a11y.A11yModule
                    ],
                    entryComponents: [
                        MatDatetimepickerContent
                    ],
                    declarations: [
                        MatDatetimepickerCalendar,
                        MatDatetimepickerCalendarBody,
                        MatDatetimepickerClock,
                        MatDatetimepicker,
                        MatDatetimepickerToggle,
                        MatDatetimepickerInput,
                        MatDatetimepickerContent,
                        MatDatetimepickerMonthView,
                        MatDatetimepickerYearView,
                        MatDatetimepickerMultiYearView
                    ],
                    exports: [
                        MatDatetimepickerCalendar,
                        MatDatetimepickerCalendarBody,
                        MatDatetimepickerClock,
                        MatDatetimepicker,
                        MatDatetimepickerToggle,
                        MatDatetimepickerInput,
                        MatDatetimepickerContent,
                        MatDatetimepickerMonthView,
                        MatDatetimepickerYearView,
                        MatDatetimepickerMultiYearView
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: datetimepicker/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: mat-datetimepicker-core.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.CLOCK_INNER_RADIUS = CLOCK_INNER_RADIUS;
    exports.CLOCK_OUTER_RADIUS = CLOCK_OUTER_RADIUS;
    exports.CLOCK_RADIUS = CLOCK_RADIUS;
    exports.CLOCK_TICK_RADIUS = CLOCK_TICK_RADIUS;
    exports.DatetimeAdapter = DatetimeAdapter;
    exports.MAT_DATETIMEPICKER_VALIDATORS = MAT_DATETIMEPICKER_VALIDATORS;
    exports.MAT_DATETIMEPICKER_VALUE_ACCESSOR = MAT_DATETIMEPICKER_VALUE_ACCESSOR;
    exports.MAT_DATETIME_FORMATS = MAT_DATETIME_FORMATS;
    exports.MAT_NATIVE_DATETIME_FORMATS = MAT_NATIVE_DATETIME_FORMATS;
    exports.MatDatetimepicker = MatDatetimepicker;
    exports.MatDatetimepickerCalendar = MatDatetimepickerCalendar;
    exports.MatDatetimepickerCalendarBody = MatDatetimepickerCalendarBody;
    exports.MatDatetimepickerCalendarCell = MatDatetimepickerCalendarCell;
    exports.MatDatetimepickerClock = MatDatetimepickerClock;
    exports.MatDatetimepickerContent = MatDatetimepickerContent;
    exports.MatDatetimepickerFilterType = MatDatetimepickerFilterType;
    exports.MatDatetimepickerInput = MatDatetimepickerInput;
    exports.MatDatetimepickerInputEvent = MatDatetimepickerInputEvent;
    exports.MatDatetimepickerModule = MatDatetimepickerModule;
    exports.MatDatetimepickerMonthView = MatDatetimepickerMonthView;
    exports.MatDatetimepickerToggle = MatDatetimepickerToggle;
    exports.MatDatetimepickerYearView = MatDatetimepickerYearView;
    exports.MatNativeDatetimeModule = MatNativeDatetimeModule;
    exports.NativeDatetimeAdapter = NativeDatetimeAdapter;
    exports.NativeDatetimeModule = NativeDatetimeModule;
    exports.ɵa = slideCalendar;
    exports.ɵb = MatDatetimepickerMultiYearView;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=mat-datetimepicker-core.umd.js.map
