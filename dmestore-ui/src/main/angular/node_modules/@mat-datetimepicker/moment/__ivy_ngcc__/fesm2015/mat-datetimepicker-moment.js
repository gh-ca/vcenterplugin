import { Injectable, Optional, Inject, NgModule } from '@angular/core';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS, MomentDateModule, MatMomentDateModule } from '@angular/material-moment-adapter';
import { DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MAT_DATE_LOCALE, DateAdapter } from '@angular/material/core';
import * as moment_ from 'moment';

/**
 * @fileoverview added by tsickle
 * Generated from: adapter/moment-datetime-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/material/core';
const moment = moment_;
/**
 * @template T
 * @param {?} length
 * @param {?} valueFunction
 * @return {?}
 */
function range(length, valueFunction) {
    /** @type {?} */
    const valuesArray = Array(length);
    for (let i = 0; i < length; i++) {
        valuesArray[i] = valueFunction(i);
    }
    return valuesArray;
}
class MomentDatetimeAdapter extends DatetimeAdapter {
    /**
     * @param {?} matDateLocale
     * @param {?} matMomentAdapterOptions
     * @param {?} _delegate
     */
    constructor(matDateLocale, matMomentAdapterOptions, _delegate) {
        super(_delegate);
        this._useUtc = false;
        this.setLocale(matDateLocale || moment.locale());
        this._useUtc = matMomentAdapterOptions.useUtc;
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        super.setLocale(locale);
        /** @type {?} */
        const momentLocaleData = moment.localeData(locale);
        this._localeData = {
            firstDayOfWeek: momentLocaleData.firstDayOfWeek(),
            longMonths: momentLocaleData.months(),
            shortMonths: momentLocaleData.monthsShort(),
            dates: range(31, (/**
             * @param {?} i
             * @return {?}
             */
            (i) => super.createDate(2017, 0, i + 1).format("D"))),
            hours: range(24, (/**
             * @param {?} i
             * @return {?}
             */
            (i) => this.createDatetime(2017, 0, 1, i, 0).format("H"))),
            minutes: range(60, (/**
             * @param {?} i
             * @return {?}
             */
            (i) => this.createDatetime(2017, 0, 1, 1, i).format("m"))),
            longDaysOfWeek: momentLocaleData.weekdays(),
            shortDaysOfWeek: momentLocaleData.weekdaysShort(),
            narrowDaysOfWeek: momentLocaleData.weekdaysMin()
        };
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getHour(date) {
        return super.clone(date).hour();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMinute(date) {
        return super.clone(date).minute();
    }
    /**
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    isInNextMonth(startDate, endDate) {
        /** @type {?} */
        const nextMonth = this.getDateInNextMonth(startDate);
        return super.sameMonthAndYear(nextMonth, endDate);
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @param {?} hour
     * @param {?} minute
     * @return {?}
     */
    createDatetime(year, month, date, hour, minute) {
        // Check for invalid month and date (except upper bound on date which we have to check after
        // creating the Date).
        if (month < 0 || month > 11) {
            throw Error(`Invalid month index "${month}". Month index has to be between 0 and 11.`);
        }
        if (date < 1) {
            throw Error(`Invalid date "${date}". Date has to be greater than 0.`);
        }
        if (hour < 0 || hour > 23) {
            throw Error(`Invalid hour "${hour}". Hour has to be between 0 and 23.`);
        }
        if (minute < 0 || minute > 59) {
            throw Error(`Invalid minute "${minute}". Minute has to be between 0 and 59.`);
        }
        // const result = moment({year, month, date, hour, minute}).locale(this.locale);
        /** @type {?} */
        let result = moment({ year, month, date, hour, minute });
        if (this._useUtc) {
            result = result.utc();
        }
        // If the result isn't valid, the date must have been out of bounds for this month.
        if (!result.isValid()) {
            throw Error(`Invalid date "${date}" for month with index "${month}".`);
        }
        return result;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getFirstDateOfMonth(date) {
        return super.clone(date).startOf("month");
    }
    /**
     * @return {?}
     */
    getHourNames() {
        return this._localeData.hours;
    }
    /**
     * @return {?}
     */
    getMinuteNames() {
        return this._localeData.minutes;
    }
    /**
     * @param {?} date
     * @param {?} hours
     * @return {?}
     */
    addCalendarHours(date, hours) {
        return super.clone(date).add({ hours });
    }
    /**
     * @param {?} date
     * @param {?} minutes
     * @return {?}
     */
    addCalendarMinutes(date, minutes) {
        return super.clone(date).add({ minutes });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    deserialize(value) {
        return this._delegate.deserialize(value);
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    getDateInNextMonth(date) {
        return super.clone(date).date(1).add({ month: 1 });
    }
}
MomentDatetimeAdapter.ɵfac = function MomentDatetimeAdapter_Factory(t) { return new (t || MomentDatetimeAdapter)(ɵngcc0.ɵɵinject(MAT_DATE_LOCALE, 8), ɵngcc0.ɵɵinject(MAT_MOMENT_DATE_ADAPTER_OPTIONS, 8), ɵngcc0.ɵɵinject(ɵngcc1.DateAdapter)); };
MomentDatetimeAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MomentDatetimeAdapter, factory: MomentDatetimeAdapter.ɵfac });
/** @nocollapse */
MomentDatetimeAdapter.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_LOCALE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_MOMENT_DATE_ADAPTER_OPTIONS,] }] },
    { type: DateAdapter }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MomentDatetimeAdapter, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_DATE_LOCALE]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_MOMENT_DATE_ADAPTER_OPTIONS]
            }] }, { type: ɵngcc1.DateAdapter }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    MomentDatetimeAdapter.prototype._localeData;
    /**
     * @type {?}
     * @private
     */
    MomentDatetimeAdapter.prototype._useUtc;
}

/**
 * @fileoverview added by tsickle
 * Generated from: adapter/moment-datetime-formats.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAT_MOMENT_DATETIME_FORMATS = {
    parse: {
        dateInput: "L",
        monthInput: "MMMM",
        timeInput: "LT",
        datetimeInput: "L LT"
    },
    display: {
        dateInput: "L",
        monthInput: "MMMM",
        datetimeInput: "L LT",
        timeInput: "LT",
        monthYearLabel: "MMM YYYY",
        dateA11yLabel: "LL",
        monthYearA11yLabel: "MMMM YYYY",
        popupHeaderDateLabel: "ddd, DD MMM"
    }
};

/**
 * @fileoverview added by tsickle
 * Generated from: adapter/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MomentDatetimeModule {
}
MomentDatetimeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MomentDatetimeModule });
MomentDatetimeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MomentDatetimeModule_Factory(t) { return new (t || MomentDatetimeModule)(); }, providers: [
        {
            provide: DatetimeAdapter,
            useClass: MomentDatetimeAdapter
        }
    ], imports: [[MomentDateModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MomentDatetimeModule, { imports: function () { return [MomentDateModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MomentDatetimeModule, [{
        type: NgModule,
        args: [{
                imports: [MomentDateModule],
                providers: [
                    {
                        provide: DatetimeAdapter,
                        useClass: MomentDatetimeAdapter
                    }
                ]
            }]
    }], null, null); })();
const ɵ0 = MAT_MOMENT_DATETIME_FORMATS;
class MatMomentDatetimeModule {
}
MatMomentDatetimeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatMomentDatetimeModule });
MatMomentDatetimeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatMomentDatetimeModule_Factory(t) { return new (t || MatMomentDatetimeModule)(); }, providers: [{ provide: MAT_DATETIME_FORMATS, useValue: ɵ0 }], imports: [[MomentDatetimeModule, MatMomentDateModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMomentDatetimeModule, { imports: function () { return [MomentDatetimeModule, MatMomentDateModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatMomentDatetimeModule, [{
        type: NgModule,
        args: [{
                imports: [MomentDatetimeModule, MatMomentDateModule],
                providers: [{ provide: MAT_DATETIME_FORMATS, useValue: ɵ0 }]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: mat-datetimepicker-moment.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MAT_MOMENT_DATETIME_FORMATS, MatMomentDatetimeModule, MomentDatetimeAdapter, MomentDatetimeModule };

//# sourceMappingURL=mat-datetimepicker-moment.js.map