import { Inject, Injectable, InjectionToken } from '@angular/core';
import { BehaviorSubject, from, of } from 'rxjs';
import { catchError, first, map, mergeAll, switchMap } from 'rxjs/operators';
import { NgxPermissionsStore } from '../store/permissions.store';
import { isBoolean, isFunction, transformStringToArray } from '../utils/utils';
export const USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');
export class NgxPermissionsService {
    constructor(isolate = false, permissionsStore) {
        this.isolate = isolate;
        this.permissionsStore = permissionsStore;
        this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;
        this.permissions$ = this.permissionsSource.asObservable();
    }
    /**
     * Remove all permissions from permissions source
     */
    flushPermissions() {
        this.permissionsSource.next({});
    }
    hasPermission(permission) {
        if (!permission || (Array.isArray(permission) && permission.length === 0)) {
            return Promise.resolve(true);
        }
        permission = transformStringToArray(permission);
        return this.hasArrayPermission(permission);
    }
    loadPermissions(permissions, validationFunction) {
        const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});
        this.permissionsSource.next(newPermissions);
    }
    addPermission(permission, validationFunction) {
        if (Array.isArray(permission)) {
            const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);
            this.permissionsSource.next(permissions);
        }
        else {
            const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);
            this.permissionsSource.next(permissions);
        }
    }
    removePermission(permissionName) {
        const permissions = Object.assign({}, this.permissionsSource.value);
        delete permissions[permissionName];
        this.permissionsSource.next(permissions);
    }
    getPermission(name) {
        return this.permissionsSource.value[name];
    }
    getPermissions() {
        return this.permissionsSource.value;
    }
    reducePermission(source, name, validationFunction) {
        if (!!validationFunction && isFunction(validationFunction)) {
            return Object.assign(Object.assign({}, source), { [name]: { name, validationFunction } });
        }
        return Object.assign(Object.assign({}, source), { [name]: { name } });
    }
    hasArrayPermission(permissions) {
        const promises = permissions.map(key => {
            if (this.hasPermissionValidationFunction(key)) {
                const validationFunction = this.permissionsSource.value[key].validationFunction;
                const immutableValue = Object.assign({}, this.permissionsSource.value);
                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?
                    of(promise) : promise), catchError(() => of(false)));
            }
            // check for name of the permission if there is no validation function
            return of(!!this.permissionsSource.value[key]);
        });
        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);
    }
    hasPermissionValidationFunction(key) {
        return !!this.permissionsSource.value[key] &&
            !!this.permissionsSource.value[key].validationFunction &&
            isFunction(this.permissionsSource.value[key].validationFunction);
    }
}
NgxPermissionsService.decorators = [
    { type: Injectable }
];
NgxPermissionsService.ctorParameters = () => [
    { type: Boolean, decorators: [{ type: Inject, args: [USE_PERMISSIONS_STORE,] }] },
    { type: NgxPermissionsStore }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbnMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wZXJtaXNzaW9ucy9zcmMvbGliL3NlcnZpY2UvcGVybWlzc2lvbnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQStCLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM5RSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSTdFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRWpFLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLHNCQUFzQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFNL0UsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxjQUFjLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUdqRixNQUFNLE9BQU8scUJBQXFCO0lBSzlCLFlBQzJDLFVBQW1CLEtBQUssRUFDdkQsZ0JBQXFDO1FBRE4sWUFBTyxHQUFQLE9BQU8sQ0FBaUI7UUFDdkQscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFxQjtRQUU3QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBdUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDO1FBQ3RILElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzlELENBQUM7SUFFRDs7T0FFRztJQUNJLGdCQUFnQjtRQUNuQixJQUFJLENBQUMs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QUFDO1lBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQjtZQUN0RCxVQUFVLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7OztZQTdHSixVQUFVOzs7MENBT0YsTUFBTSxTQUFDLHFCQUFxQjtZQWpCNUIsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGZyb20sIE9ic2VydmFibGUsIE9ic2VydmFibGVJbnB1dCwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGZpcnN0LCBtYXAsIG1lcmdlQWxsLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE5neFBlcm1pc3Npb24gfSBmcm9tICcuLi9tb2RlbC9wZXJtaXNzaW9uLm1vZGVsJztcbmltcG9ydCB7IFZhbGlkYXRpb25GbiB9IGZyb20gJy4uL21vZGVsL3Blcm1pc3Npb25zLXJvdXRlci1kYXRhLm1vZGVsJztcbmltcG9ydCB7IE5neFBlcm1pc3Npb25zU3RvcmUgfSBmcm9tICcuLi9zdG9yZS9wZXJtaXNzaW9ucy5zdG9yZSc7XG5cbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNGdW5jdGlvbiwgdHJhbnNmb3JtU3RyaW5nVG9BcnJheSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBOZ3hQZXJtaXNzaW9uc09iamVjdCB7XG4gICAgW25hbWU6IHN0cmluZ106IE5neFBlcm1pc3Npb247XG59XG5cbmV4cG9ydCBjb25zdCBVU0VfUEVSTUlTU0lPTlNfU1RPUkUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1VTRV9QRVJNSVNTSU9OU19TVE9SRScpO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmd4UGVybWlzc2lvbnNTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgcGVybWlzc2lvbnNTb3VyY2U6IEJlaGF2aW9yU3ViamVjdDxOZ3hQZXJtaXNzaW9uc09iamVjdD47XG4gICAgcHVibGljIHBlcm1pc3Npb25zJDogT2JzZXJ2YWJsZTxOZ3hQZXJtaXNzaW9uc09iamVjdD47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChVU0VfUEVSTUlTU0lPTlNfU1RPUkUpIHByaXZhdGUgaXNvbGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBwcml2YXRlIHBlcm1pc3Npb25zU3RvcmU6IE5neFBlcm1pc3Npb25zU3RvcmVcbiAgICApIHtcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uc1NvdXJjZSA9IGlzb2xhdGUgPyBuZXcgQmVoYXZpb3JTdWJqZWN0PE5neFBlcm1pc3Npb25zT2JqZWN0Pih7fSkgOiBwZXJtaXNzaW9uc1N0b3JlLnBlcm1pc3Npb25zU291cmNlO1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zJCA9IHRoaXMucGVybWlzc2lvbnNTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBwZXJtaXNzaW9ucyBmcm9tIHBlcm1pc3Npb25zIHNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBmbHVzaFBlcm1pc3Npb25zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zU291cmNlLm5leHQoe30pO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYXNQZXJtaXNzaW9uKHBlcm1pc3Npb246IHN0cmluZyB8IHN0cmluZ1tdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGlmICghcGVybWlzc2lvbiB8fCAoQXJyYXkuaXNBcnJheShwZXJtaXNzaW9uKSAmJiBwZXJtaXNzaW9uLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJtaXNzaW9uID0gdHJhbnNmb3JtU3RyaW5nVG9BcnJheShwZXJtaXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXJyYXlQZXJtaXNzaW9uKHBlcm1pc3Npb24pO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkUGVybWlzc2lvbnMocGVybWlzc2lvbnM6IHN0cmluZ1tdLCB2YWxpZGF0aW9uRnVuY3Rpb24/OiBWYWxpZGF0aW9uRm4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbmV3UGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucy5yZWR1Y2UoXG4gICAgICAgICAgICAoc291cmNlLCBuYW1lKSA9PiB0aGlzLnJlZHVjZVBlcm1pc3Npb24oc291cmNlLCBuYW1lLCB2YWxpZGF0aW9uRnVuY3Rpb24pLCB7fVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zU291cmNlLm5leHQobmV3UGVybWlzc2lvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRQZXJtaXNzaW9uKHBlcm1pc3Npb246IHN0cmluZyB8IHN0cmluZ1tdLCB2YWxpZGF0aW9uRnVuY3Rpb24/OiBWYWxpZGF0aW9uRm4pOiB2b2lkIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGVybWlzc2lvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGVybWlzc2lvbi5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKHNvdXJjZSwgbmFtZSkgPT4gdGhpcy5yZWR1Y2VQZXJtaXNzaW9uKHNvdXJjZSwgbmFtZSwgdmFsaWRhdGlvbkZ1bmN0aW9uKSwgdGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uc1NvdXJjZS5uZXh0KHBlcm1pc3Npb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gdGhpcy5yZWR1Y2VQZXJtaXNzaW9uKHRoaXMucGVybWlzc2lvbnNTb3VyY2UudmFsdWUsIHBlcm1pc3Npb24sIHZhbGlkYXRpb25GdW5jdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbnNTb3VyY2UubmV4dChwZXJtaXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlUGVybWlzc2lvbihwZXJtaXNzaW9uTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgcGVybWlzc2lvbnNbcGVybWlzc2lvbk5hbWVdO1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zU291cmNlLm5leHQocGVybWlzc2lvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRQZXJtaXNzaW9uKG5hbWU6IHN0cmluZyk6IE5neFBlcm1pc3Npb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZVtuYW1lXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UGVybWlzc2lvbnMoKTogTmd4UGVybWlzc2lvbnNPYmplY3Qge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlZHVjZVBlcm1pc3Npb24oc291cmNlOiBOZ3hQZXJtaXNzaW9uc09iamVjdCwgbmFtZTogc3RyaW5nLCB2YWxpZGF0aW9uRnVuY3Rpb24/OiBWYWxpZGF0aW9uRm4pOiBOZ3hQZXJtaXNzaW9uc09iamVjdCB7XG4gICAgICAgIGlmICghIXZhbGlkYXRpb25GdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKHZhbGlkYXRpb25GdW5jdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc291cmNlLFxuICAgICAgICAgICAgICAgIFtuYW1lXToge25hbWUsIHZhbGlkYXRpb25GdW5jdGlvbn1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNvdXJjZSxcbiAgICAgICAgICAgIFtuYW1lXToge25hbWV9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNBcnJheVBlcm1pc3Npb24ocGVybWlzc2lvbnM6IHN0cmluZ1tdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzOiBPYnNlcnZhYmxlPGJvb2xlYW4+W10gPSBwZXJtaXNzaW9ucy5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1Blcm1pc3Npb25WYWxpZGF0aW9uRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25GdW5jdGlvbiA9IHRoaXMucGVybWlzc2lvbnNTb3VyY2UudmFsdWVba2V5XS52YWxpZGF0aW9uRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgaW1tdXRhYmxlVmFsdWUgPSB7Li4udGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZX07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgbWFwKCgpID0+IHZhbGlkYXRpb25GdW5jdGlvbihrZXksIGltbXV0YWJsZVZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaE1hcCgocHJvbWlzZTogUHJvbWlzZTxib29sZWFuPiB8IGJvb2xlYW4pOiBPYnNlcnZhYmxlSW5wdXQ8Ym9vbGVhbj4gPT4gaXNCb29sZWFuKHByb21pc2UpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mKHByb21pc2UgYXMgYm9vbGVhbikgOiBwcm9taXNlIGFzIFByb21pc2U8Ym9vbGVhbj4pLFxuICAgICAgICAgICAgICAgICAgICBjYXRjaEVycm9yKCgpID0+IG9mKGZhbHNlKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgbmFtZSBvZiB0aGUgcGVybWlzc2lvbiBpZiB0aGVyZSBpcyBubyB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gb2YoISF0aGlzLnBlcm1pc3Npb25zU291cmNlLnZhbHVlW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlcykucGlwZShcbiAgICAgICAgICAgIG1lcmdlQWxsKCksXG4gICAgICAgICAgICBmaXJzdCgoZGF0YSkgPT4gZGF0YSAhPT0gZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgICAgIG1hcCgoZGF0YSkgPT4gZGF0YSAhPT0gZmFsc2UpXG4gICAgICAgICkudG9Qcm9taXNlKCkudGhlbigoZGF0YTogYW55KSA9PiBkYXRhKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc1Blcm1pc3Npb25WYWxpZGF0aW9uRnVuY3Rpb24oa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZVtrZXldICYmXG4gICAgICAgICAgICAhIXRoaXMucGVybWlzc2lvbnNTb3VyY2UudmFsdWVba2V5XS52YWxpZGF0aW9uRnVuY3Rpb24gJiZcbiAgICAgICAgICAgIGlzRnVuY3Rpb24odGhpcy5wZXJtaXNzaW9uc1NvdXJjZS52YWx1ZVtrZXldLnZhbGlkYXRpb25GdW5jdGlvbik7XG4gICAgfVxuXG59XG4iXX0=