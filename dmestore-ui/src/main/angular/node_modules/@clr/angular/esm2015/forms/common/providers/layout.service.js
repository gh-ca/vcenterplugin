/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
export var Layouts;
(function (Layouts) {
    Layouts["VERTICAL"] = "vertical";
    Layouts["HORIZONTAL"] = "horizontal";
    Layouts["COMPACT"] = "compact";
})(Layouts || (Layouts = {}));
export class LayoutService {
    constructor() {
        this.minLabelSize = 1;
        this.maxLabelSize = 12;
        this.layout = Layouts.HORIZONTAL;
        // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
        // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
        // this exists to deal with this little caveat to get the list of the values as an array.
        this.layoutValues = Object.keys(Layouts).map(key => Layouts[key]);
        this._labelSize = 2;
    }
    set labelSize(size) {
        if (this.labelSizeIsValid(size)) {
            this._labelSize = size;
        }
    }
    get labelSize() {
        return this._labelSize;
    }
    isVertical() {
        return this.layout === Layouts.VERTICAL;
    }
    isHorizontal() {
        return this.layout === Layouts.HORIZONTAL;
    }
    isCompact() {
        return this.layout === Layouts.COMPACT;
    }
    get layoutClass() {
        return `clr-form-${this.layout}`;
    }
    isValid(layout) {
        return this.layoutValues.indexOf(layout) > -1;
    }
    labelSizeIsValid(labelSize) {
        return Number.isInteger(labelSize) && labelSize >= this.minLabelSize && labelSize <= this.maxLabelSize;
    }
}
LayoutService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5b3V0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9hbmd1bGFyL3Byb2plY3RzL2Nsci1hbmd1bGFyL3NyYy9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFFSCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE1BQU0sQ0FBTixJQUFZLE9BSVg7QUFKRCxXQUFZLE9BQU87SUFDakIsZ0NBQXFCLENBQUE7SUFDckIsb0NBQXlCLENBQUE7SUFDekIsOEJBQW1CLENBQUE7QUFDckIsQ0FBQyxFQUpXLE9BQU8sS0FBUCxPQUFPLFFBSWxCO0FBR0QsTUFBTSxPQUFPLGFBQWE7SUFEMUI7UUFFVyxpQkFBWSxHQUFHLENBQUMsQ0FBQztRQUNqQixpQkFBWSxHQUFHLEVBQUUsQ0FBQztRQUMzQixXQUFNLEdBQVksT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUVyQywrRkFBK0Y7UUFDL0YsaUdBQWlHO1FBQ2pHLHlGQUF5RjtRQUNqRixpQkFBWSxHQUFhLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUUsT0FBK0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2hHLGVBQVUsR0FBRyxDQUFDLENBQUM7SUFtQ3pCLENBQUM7SUFqQ0MsSUFBSSxTQUFTLENBQUMsSUFBWTtRQUN4QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztTQUN4QjtJQUNILENBQUM7SUFFRCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVELFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUMxQyxDQUFDO0lBRUQsWUFBWTtRQUNWLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsVUFBVSxDQUFDO0lBQzVDLENBQUM7SUFFRCxTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDekMsQ0FBQztJQUVELElBQUksV0FBVztRQUNiLE9BQU8sWUFBWSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVELE9BQU8sQ0FBQyxNQUFjO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELGdCQUFnQixDQUFDLFNBQWlCO1FBQ2hDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQztJQUN6RyxDQUFDOzs7WUE1Q0YsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgZW51bSBMYXlvdXRzIHtcbiAgVkVSVElDQUwgPSAndmVydGljYWwnLFxuICBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnLFxuICBDT01QQUNUID0gJ2NvbXBhY3QnLFxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTGF5b3V0U2VydmljZSB7XG4gIHJlYWRvbmx5IG1pbkxhYmVsU2l6ZSA9IDE7XG4gIHJlYWRvbmx5IG1heExhYmVsU2l6ZSA9IDEyO1xuICBsYXlvdXQ6IExheW91dHMgPSBMYXlvdXRzLkhPUklaT05UQUw7XG5cbiAgLy8gVGhpcyBpcyBiYXNpY2FsbHkgYSByZXBsYWNlbWVudCBmb3IgT2JqZWN0LnZhbHVlcygpLCB3aGljaCBJRTExIGFuZCBOb2RlIDw5IGRvbid0IHN1cHBvcnQgOihcbiAgLy8gU3RyaW5nIGVudW1zIGNhbm5vdCBiZSByZXZlcnNlLW1hcHBlZCwgbWVhbmluZyBMYXlvdXRzWydDT01QQUNUJ10gZG9lcyBub3QgcmV0dXJuICdjb21wYWN0JyBzb1xuICAvLyB0aGlzIGV4aXN0cyB0byBkZWFsIHdpdGggdGhpcyBsaXR0bGUgY2F2ZWF0IHRvIGdldCB0aGUgbGlzdCBvZiB0aGUgdmFsdWVzIGFzIGFuIGFycmF5LlxuICBwcml2YXRlIGxheW91dFZhbHVlczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhMYXlvdXRzKS5tYXAoa2V5ID0+IChMYXlvdXRzIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pW2tleV0pO1xuICBwcml2YXRlIF9sYWJlbFNpemUgPSAyO1xuXG4gIHNldCBsYWJlbFNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMubGFiZWxTaXplSXNWYWxpZChzaXplKSkge1xuICAgICAgdGhpcy5fbGFiZWxTaXplID0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBnZXQgbGFiZWxTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xhYmVsU2l6ZTtcbiAgfVxuXG4gIGlzVmVydGljYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSBMYXlvdXRzLlZFUlRJQ0FMO1xuICB9XG5cbiAgaXNIb3Jpem9udGFsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gTGF5b3V0cy5IT1JJWk9OVEFMO1xuICB9XG5cbiAgaXNDb21wYWN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gTGF5b3V0cy5DT01QQUNUO1xuICB9XG5cbiAgZ2V0IGxheW91dENsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjbHItZm9ybS0ke3RoaXMubGF5b3V0fWA7XG4gIH1cblxuICBpc1ZhbGlkKGxheW91dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0VmFsdWVzLmluZGV4T2YobGF5b3V0KSA+IC0xO1xuICB9XG5cbiAgbGFiZWxTaXplSXNWYWxpZChsYWJlbFNpemU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGxhYmVsU2l6ZSkgJiYgbGFiZWxTaXplID49IHRoaXMubWluTGFiZWxTaXplICYmIGxhYmVsU2l6ZSA8PSB0aGlzLm1heExhYmVsU2l6ZTtcbiAgfVxufVxuIl19