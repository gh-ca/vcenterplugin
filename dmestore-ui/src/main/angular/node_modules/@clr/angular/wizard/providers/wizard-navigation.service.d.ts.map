{"version":3,"file":"wizard-navigation.service.d.ts","sources":["wizard-navigation.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { OnDestroy, TemplateRef } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Subscription } from 'rxjs';\nimport { ClrWizardPage } from '../wizard-page';\nimport { ButtonHubService } from './button-hub.service';\nimport { PageCollectionService } from './page-collection.service';\n/**\n * Performs navigation functions for a wizard and manages the current page. Presented as a\n * separate service to encapsulate the behavior of navigating and completing the wizard so\n * that it can be shared across the wizard and its sub-components.\n *\n * The easiest way to access the navigation service is there a reference on your wizard. The\n * Following example would allow you to access your instance of the wizard from your host\n * component and thereby access the navigation service via YourHostComponent.wizard.navService.\n *\n * @example\n * <clr-wizard #wizard ...>\n *\n * @example\n * export class YourHostComponent {\n *   @ViewChild(\"wizard\") wizard: Wizard;\n *   ...\n * }\n *\n */\nexport declare class WizardNavigationService implements OnDestroy {\n    pageCollection: PageCollectionService;\n    buttonService: ButtonHubService;\n    /**\n     * Is notified when a previous button is clicked in the wizard. Performs checks\n     * before alerting the current page of the button click. Enacts navigation to\n     * the previous page if not overridden at the page level.\n     *\n     * @memberof WizardNavigationService\n     */\n    previousButtonSubscription: Subscription;\n    /**\n     * Is notified when a Next button is clicked in the wizard.\n     *\n     * @memberof WizardNavigationService\n     */\n    nextButtonSubscription: Subscription;\n    /**\n     * Is notified when a danger button is clicked in the wizard.\n     *\n     * @memberof WizardNavigationService\n     */\n    dangerButtonSubscription: Subscription;\n    /**\n     * Is notified when a  finish button is clicked in the wizard.\n     *\n     * @memberof WizardNavigationService\n     */\n    finishButtonSubscription: Subscription;\n    /**\n     * Is notified when a Custom button is clicked in the wizard.\n     *\n     * @memberof WizardNavigationService\n     */\n    customButtonSubscription: Subscription;\n    /**\n     * Is notified when a Cancel button is clicked in the wizard. Notifies the wizard,\n     * which handles all cancel functionality, if cancel is not overridden at the page\n     * level.\n     *\n     * @memberof WizardNavigationService\n     */\n    cancelButtonSubscription: Subscription;\n    /**\n     * Resets navigation to make the first page current when the page collection service\n     * emits an event notifying WizardNavigationService that it has reset all pages\n     * to their pristine, incomplete state.\n     *\n     * @memberof WizardNavigationService\n     */\n    pagesResetSubscription: Subscription;\n    /**\n     * Creates an instance of WizardNavigationService. Also sets up subscriptions\n     * that listen to the button service to determine when a button has been clicked\n     * in the wizard. Is also responsible for taking action when the page collection\n     * requests that navigation be reset to its pristine state.\n     *\n     * @memberof WizardNavigationService\n     */\n    constructor(pageCollection: PageCollectionService, buttonService: ButtonHubService);\n    /**\n     *\n     * @memberof WizardNavigationService\n     */\n    ngOnDestroy(): void;\n    /**\n     *\n     * @memberof WizardNavigationService\n     */\n    private _currentChanged;\n    /**\n     * An Observable that is predominantly used amongst the subcomponents and services\n     * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad\n     * (clrWizardPageOnLoad) output instead of this Observable.\n     *\n     * @memberof WizardNavigationService\n     */\n    get currentPageChanged(): Observable<ClrWizardPage>;\n    /**\n     * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are\n     * loading and there is no current page defined.\n     *\n     * @memberof WizardNavigationService\n     */\n    navServiceLoaded: boolean;\n    /**\n     * A boolean flag shared across the Wizard subcomponents that follows the value\n     * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,\n     * navigating backwards in the stepnav menu will reset any skipped pages' completed\n     * state to false.\n     *\n     * This is useful when a wizard executes validation on a page-by-page basis when\n     * the next button is clicked.\n     *\n     * @memberof WizardNavigationService\n     */\n    forceForwardNavigation: boolean;\n    /**\n     * @memberof WizardNavigationService\n     */\n    get currentPageTitle(): TemplateRef<any>;\n    /**\n     * Returns a Boolean that tells you whether or not the current page is the first\n     * page in the Wizard.\n     *\n     * This is helpful for determining whether a page is navigable.\n     *\n     * @memberof WizardNavigationService\n     */\n    get currentPageIsFirst(): boolean;\n    /**\n     * Returns a Boolean that tells you whether or not the current page is the\n     * last page in the Wizard.\n     *\n     * This is used to determine which buttons should display in the wizard footer.\n     *\n     * @memberof WizardNavigationService\n     */\n    get currentPageIsLast(): boolean;\n    /**\n     * @memberof WizardNavigationService\n     */\n    private _currentPage;\n    /**\n     * Returns the ClrWizardPage object of the current page or null.\n     *\n     * @memberof WizardNavigationService\n     */\n    get currentPage(): ClrWizardPage;\n    /**\n     * Accepts a ClrWizardPage object, since that object to be the current/active\n     * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)\n     * event for that page.\n     *\n     * Note that all of this work is bypassed if the ClrWizardPage object is already\n     * the current page.\n     *\n     * @memberof WizardNavigationService\n     */\n    set currentPage(page: ClrWizardPage);\n    /**\n     * @memberof WizardNavigationService\n     */\n    private _movedToNextPage;\n    /**\n     * An observable used internally to alert the wizard that forward navigation\n     * has occurred. It is recommended that you use the Wizard.onMoveNext\n     * (clrWizardOnNext) output instead of this one.\n     *\n     * @memberof WizardNavigationService\n     */\n    get movedToNextPage(): Observable<boolean>;\n    /**\n     * @memberof WizardNavigationService\n     */\n    private _wizardFinished;\n    /**\n     * An observable used internally to alert the wizard that the nav service\n     * has approved completion of the wizard.\n     *\n     * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)\n     * output instead of this one.\n     *\n     * @memberof WizardNavigationService\n     */\n    get wizardFinished(): Observable<boolean>;\n    /**\n     * This is a public function that can be used to programmatically advance\n     * the user to the next page.\n     *\n     * When invoked, this method will move the wizard to the next page after\n     * successful validation. Note that this method goes through all checks\n     * and event emissions as if Wizard.next(false) had been called.\n     *\n     * In most cases, it makes more sense to use Wizard.next(false).\n     *\n     * @memberof WizardNavigationService\n     */\n    next(): void;\n    /**\n     * Bypasses checks and most event emissions to force a page to navigate forward.\n     *\n     * Comparable to calling Wizard.next() or Wizard.forceNext().\n     *\n     * @memberof WizardNavigationService\n     */\n    forceNext(): void;\n    /**\n     * Accepts a button/action type as a parameter. Encapsulates all logic for\n     * event emissions, state of the current page, and wizard and page level overrides.\n     *\n     * Avoid calling this function directly unless you really know what you're doing.\n     *\n     * @memberof WizardNavigationService\n     */\n    checkAndCommitCurrentPage(buttonType: string): void;\n    /**\n     * This is a public function that can be used to programmatically conclude\n     * the wizard.\n     *\n     * When invoked, this method will  initiate the work involved with finalizing\n     * and finishing the wizard workflow. Note that this method goes through all\n     * checks and event emissions as if Wizard.finish(false) had been called.\n     *\n     * In most cases, it makes more sense to use Wizard.finish(false).\n     *\n     * @memberof WizardNavigationService\n     */\n    finish(): void;\n    /**\n     * @memberof WizardNavigationService\n     */\n    private _movedToPreviousPage;\n    /**\n     * Notifies the wizard when backwards navigation has occurred via the\n     * previous button.\n     *\n     * @memberof WizardNavigationService\n     */\n    get movedToPreviousPage(): Observable<boolean>;\n    /**\n     * Programmatically moves the wizard to the page before the current page.\n     *\n     * In most instances, it makes more sense to call Wizard.previous()\n     * which does the same thing.\n     *\n     * @memberof WizardNavigationService\n     */\n    previous(): void;\n    /**\n     * @memberof WizardNavigationService\n     */\n    private _cancelWizard;\n    /**\n     * Notifies the wizard that a user is trying to cancel it.\n     *\n     * @memberof WizardNavigationService\n     */\n    get notifyWizardCancel(): Observable<any>;\n    /**\n     * Allows a hook into the cancel workflow of the wizard from the nav service. Note that\n     * this route goes through all checks and event emissions as if a cancel button had\n     * been clicked.\n     *\n     * In most cases, users looking for a hook into the cancel routine are actually looking\n     * for a way to close the wizard from their host component because they have prevented\n     * the default cancel action.\n     *\n     * In this instance, it is recommended that you use Wizard.close() to avoid any event\n     * emission loop resulting from an event handler calling back into routine that will\n     * again evoke the events it handles.\n     *\n     * @memberof WizardNavigationService\n     */\n    cancel(): void;\n    /**\n     * A boolean flag shared across the Wizard subcomponents that follows the value\n     * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel\n     * routine is subverted and must be reinstated in the host component calling Wizard.close()\n     * at some point.\n     *\n     * @memberof WizardNavigationService\n     */\n    wizardHasAltCancel: boolean;\n    /**\n     * A boolean flag shared across the Wizard subcomponents that follows the value\n     * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish\n     * routines are subverted and must be reinstated in the host component calling Wizard.next(),\n     * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().\n     *\n     * @memberof WizardNavigationService\n     */\n    wizardHasAltNext: boolean;\n    /**\n     * A boolean flag shared across the Wizard subcomponents that follows the value\n     * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all\n     * navigational elements in the wizard are disabled.\n     *\n     * This is intended to freeze the wizard in place. Events are not fired so this is\n     * not a way to implement alternate functionality for navigation.\n     *\n     * @memberof WizardNavigationService\n     */\n    wizardStopNavigation: boolean;\n    /**\n     * A boolean flag shared with the stepnav items that prevents user clicks on\n     * stepnav items from navigating the wizard.\n     *\n     * @memberof WizardNavigationService\n     */\n    wizardDisableStepnav: boolean;\n    /**\n     * Performs all required checks to determine if a user can navigate to a page. Checking at each\n     * point if a page is navigable -- completed where the page immediately after the last completed\n     * page.\n     *\n     * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the\n     * ClrWizardPage object that you want to make the current page.\n     *\n     * The second parameter is optional and is a Boolean flag for \"lazy completion\". What this means\n     * is the Wizard will mark all pages between the current page and the page you want to navigate\n     * to as completed. This is useful for informational wizards that do not require user action,\n     * allowing an easy means for users to jump ahead.\n     *\n     * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.\n     *\n     * @memberof WizardNavigationService\n     */\n    goTo(pageToGoToOrId: any, lazyComplete?: boolean): void;\n    /**\n     * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking\n     * those objects to determine if navigation can be accomplished.\n     *\n     * @memberof WizardNavigationService\n     */\n    canGoTo(pagesToCheck: ClrWizardPage[]): boolean;\n    /**\n     * Looks through the collection of pages to find the first one that is incomplete\n     * and makes that page the current/active page.\n     *\n     * @memberof WizardNavigationService\n     */\n    setLastEnabledPageCurrent(): void;\n    /**\n     * Finds the first page in the collection of pages and makes that page the\n     * current/active page.\n     *\n     * @memberof WizardNavigationService\n     */\n    setFirstPageCurrent(): void;\n    /**\n     * Updates the stepnav on the left side of the wizard when pages are dynamically\n     * added or removed from the collection of pages.\n     *\n     * @memberof WizardNavigationService\n     */\n    updateNavigation(): void;\n}\n"]}