/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { baseStyles, hasStringPropertyChanged, hasStringPropertyChangedAndNotNil, property, internalProperty, id, } from '@clr/core/internal';
import { html, LitElement, query } from 'lit-element';
import { styles } from './icon.element.css.js';
import { ClarityIcons } from './icon.service.js';
import { updateIconSizeStyleOrClassnames } from './utils/icon.classnames.js';
import { hasIcon } from './utils/icon.service-helpers.js';
/**
 * Icon component that renders svg shapes that can be customized.
 * To load an icon, import the icon with the icon service.
 *
 * ```typescript
 * import '@clr/core/icon/register.js';
 * import { ClarityIcons, userIcon } from '@clr/core/icon';
 *
 * ClarityIcons.addIcons(userIcon);
 * ```
 *
 * ```html
 * <cds-icon shape="user"></cds-icon>
 * ```
 *
 * @element cds-icon
 * @cssprop --color
 * @cssprop --badge-color
 */
export class CdsIcon extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Displays most icons in their "filled" version if set to `true`.
         */
        this.solid = false;
        /**
         * @type {info | success | warning | danger | highlight}
         * Changes color of icon fills and outlines
         */
        this.status = '';
        /**
         * Inverts color of icon fills and outlines if `true`.
         * Useful for displaying icons on a dark background.
         */
        this.inverse = false;
        /**
         * @private
         * given a pixel value offset any surrounding whitespace within the svg
         */
        this.innerOffset = 0;
    }
    static get styles() {
        return [baseStyles, styles];
    }
    get shape() {
        return hasIcon(this._shape, ClarityIcons.registry) ? this._shape : 'unknown';
    }
    /**
     * Changes the svg glyph displayed in the icon component. Defaults to the 'unknown' icon if
     * the specified icon cannot be found in the icon registry.
     */
    set shape(val) {
        if (hasStringPropertyChangedAndNotNil(val, this._shape)) {
            const oldVal = this._shape;
            this._shape = val;
            this.requestUpdate('shape', oldVal);
        }
    }
    get size() {
        return this._size;
    }
    /**
     * @type {string | sm | md | lg | xl | xxl}
     * Apply numerical width-height or a t-shirt-sized CSS classname
     */
    set size(val) {
        if (hasStringPropertyChanged(val, this._size)) {
            const oldVal = this._size;
            this._size = val;
            updateIconSizeStyleOrClassnames(this, val);
            this.requestUpdate('size', oldVal);
        }
    }
    firstUpdated(props) {
        super.firstUpdated(props);
        this.updateSVGAriaLabel();
    }
    updated(props) {
        if (props.has('title')) {
            this.updateSVGAriaLabel();
        }
        if (props.has('innerOffset') && this.innerOffset > 0) {
            const dimension = `calc(100% + ${this.innerOffset * 2}px)`;
            this.svg.style.width = dimension;
            this.svg.style.height = dimension;
            this.svg.style.margin = `-${this.innerOffset} 0 0 -${this.innerOffset}`;
        }
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute('role', 'none');
    }
    render() {
        return html `
      <span .innerHTML="${ClarityIcons.registry[this.shape]}"></span>
      ${this.title
            ? html `<span id="${this.idForAriaLabel}" cds-layout="display:screen-reader-only">${this.title}</span>`
            : ''}
    `;
    }
    updateSVGAriaLabel() {
        if (this.title) {
            this.svg.removeAttribute('aria-label'); // remove empty label that makes icon decorative by default
            this.svg.setAttribute('aria-labelledby', this.idForAriaLabel); // use labelledby for better SR support
        }
        else {
            this.svg.removeAttribute('aria-labelledby');
        }
    }
}
__decorate([
    property({ type: String })
], CdsIcon.prototype, "shape", null);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "size", null);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "title", void 0);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "dir", void 0);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "direction", void 0);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "flip", void 0);
__decorate([
    property({ type: Boolean })
], CdsIcon.prototype, "solid", void 0);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "status", void 0);
__decorate([
    property({ type: Boolean })
], CdsIcon.prototype, "inverse", void 0);
__decorate([
    property({ type: String })
], CdsIcon.prototype, "badge", void 0);
__decorate([
    internalProperty({ type: Number, reflect: true })
], CdsIcon.prototype, "innerOffset", void 0);
__decorate([
    query('svg')
], CdsIcon.prototype, "svg", void 0);
__decorate([
    id()
], CdsIcon.prototype, "idForAriaLabel", void 0);
//# sourceMappingURL=icon.element.js.map