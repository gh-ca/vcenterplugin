/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { assignSlotNames, badgeSlot, baseStyles, CdsBaseButton, getElementWidth, iconSpinner, iconSpinnerCheck, iconSlot, property, } from '@clr/core/internal';
import { ClarityIcons } from '@clr/core/icon/icon.service.js';
import { errorStandardIcon } from '@clr/core/icon/shapes/error-standard.js';
import { html, query } from 'lit-element';
import { styles as baseButtonStyles } from './base-button.element.css.js';
import { styles } from './button.element.css.js';
// TODO: when we migrate away from the base64 icons in other states, we will need to either move the consts
// into this file or move the base button here. pulling cds-icons into core/internal creates a circular dependency
const iconSpinnerError = html `<span class="button-status-icon" cds-layout="horizontal align:center"
  ><cds-icon shape="error-standard" cds-layout="align:center"></cds-icon
></span>`;
export var ClrLoadingState;
(function (ClrLoadingState) {
    ClrLoadingState["DEFAULT"] = "default";
    ClrLoadingState["LOADING"] = "loading";
    ClrLoadingState["SUCCESS"] = "success";
    ClrLoadingState["ERROR"] = "error";
})(ClrLoadingState || (ClrLoadingState = {}));
function buttonSlots(icon, badge) {
    // nested span tags allow for line-height erasers on the innermost span and flex-based centering on the outermost span
    const textSlot = html `<span class="button-content"
    ><span><slot></slot></span
  ></span>`;
    const slotWithIcon = html `${iconSlot}${textSlot}`;
    const slotWithBadge = html `${textSlot}${badgeSlot}`;
    const slotWithContentAndBadge = html `${iconSlot}${textSlot}${badgeSlot}`;
    switch (true) {
        case icon === true && badge === true:
            return html `${slotWithContentAndBadge}`;
        case icon === true:
            return html `${slotWithIcon}`;
        case badge === true:
            return html `${slotWithBadge}`;
        default:
            return html `${textSlot}`;
    }
}
/**
 * Buttons allow an application to communicate action and direct user intent.
 *
 * ```typescript
 * import '@clr/core/button/register.js';
 * ```
 *
 * ```html
 * <cds-button>submit</cds-button>
 * ```
 *
 * @beta
 * @element cds-button
 * @slot - Content slot for inside the button
 * @cssprop --background
 * @cssprop --border-color
 * @cssprop --border-radius
 * @cssprop --border-width
 * @cssprop --box-shadow-color
 * @cssprop --color
 * @cssprop --font-family
 * @cssprop --font-size
 * @cssprop --font-weight
 * @cssprop --height
 * @cssprop --letter-spacing
 * @cssprop --min-width
 * @cssprop --padding
 * @cssprop --text-decoration
 * @cssprop --text-transform
 */
export class CdsButton extends CdsBaseButton {
    constructor() {
        super();
        /**
         * Define the type of action the button triggers
         *
         * - `solid`: buttons direct the userâ€™s attention to the primary action the application is suggesting that the user take.
         * - `outline`: buttons indicate secondary actions that compliments a primary action or reduces visual noise when there are many actions on the page.
         * - `flat`: buttons are used as tertiary buttons. Can also be used inline because they are different from content in style and recognizable as buttons alongside content.
         */
        this.action = 'solid';
        /**
         * Sets the color of the button to match the following string statuses
         */
        this.status = 'primary';
        /**
         * Sets the overall height and width of the button based on the following string values:
         */
        this.size = 'md';
        /** Sets if the button should be full width with display block */
        this.block = false;
        /**
         * @type {default | loading | success | error}
         * Changes the button content based on the value passed.
         *
         * - `default`: shows the content of the button
         * - `loading`: disables the button and shows a spinner inside the button
         * - `success`: disables the button and shows a check mark inside the button; auto-triggers to change back to DEFAULT state after 1000 ms
         * - `error`: shows the content of the button (in the context of application, this state is usually entered from a LOADING state. the application should show appropriate error message)
         */
        this.loadingState = ClrLoadingState.DEFAULT;
        ClarityIcons.addIcons(errorStandardIcon);
    }
    firstUpdated(props) {
        super.firstUpdated(props);
        if (this.loadingState !== ClrLoadingState.DEFAULT) {
            this.updateLoadingState();
        }
    }
    connectedCallback() {
        super.connectedCallback();
        assignSlotNames([this.icon, 'button-icon'], [this.badge, 'button-badge']);
    }
    update(props) {
        if (this.privateHost && props.has('loadingState')) {
            this.updateLoadingState();
        }
        super.update(props);
    }
    render() {
        const loadingState = this.loadingState;
        const hasIcon = !!this.icon;
        const hasBadge = !!this.badge;
        return html `<div class="private-host" cds-layout="horizontal wrap:none">
      ${loadingState === ClrLoadingState.SUCCESS ? html `${iconSpinnerCheck}` : ''}${loadingState ===
            ClrLoadingState.ERROR
            ? html `${iconSpinnerError}`
            : ''}${loadingState === ClrLoadingState.LOADING ? html `${iconSpinner}` : ''}${loadingState ===
            ClrLoadingState.DEFAULT
            ? html `${buttonSlots(hasIcon, hasBadge)}`
            : ''}${this.hiddenButtonTemplate}
    </div>`;
    }
    static get styles() {
        return [baseStyles, baseButtonStyles, styles];
    }
    updateLoadingState() {
        switch (this.loadingState) {
            case ClrLoadingState.LOADING:
                this.disableButton();
                return;
            case ClrLoadingState.SUCCESS:
                this.disableButton();
                return;
            case ClrLoadingState.ERROR:
                this.disableButton();
                return;
            default:
                this.enableButton();
        }
    }
    disableButton() {
        this.style.width = getElementWidth(this);
        this.disabled = true;
    }
    enableButton() {
        this.loadingState = ClrLoadingState.DEFAULT;
        this.style.removeProperty('width');
        this.disabled = false;
    }
}
__decorate([
    property({ type: String })
], CdsButton.prototype, "action", void 0);
__decorate([
    property({ type: String })
], CdsButton.prototype, "status", void 0);
__decorate([
    property({ type: String })
], CdsButton.prototype, "size", void 0);
__decorate([
    property({ type: Boolean })
], CdsButton.prototype, "block", void 0);
__decorate([
    query('.private-host')
], CdsButton.prototype, "privateHost", void 0);
__decorate([
    property({ type: String })
], CdsButton.prototype, "loadingState", void 0);
//# sourceMappingURL=button.element.js.map