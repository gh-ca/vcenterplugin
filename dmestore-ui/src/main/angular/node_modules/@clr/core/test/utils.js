/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
export const spyOnFunction = (obj, func) => {
    // eslint-disable-next-line jasmine/no-unsafe-spy
    const spy = jasmine.createSpy(func);
    spyOnProperty(obj, func, 'get').and.returnValue(spy);
    return spy;
};
export function createTestElement() {
    const element = document.createElement('div');
    document.body.appendChild(element);
    return element;
}
export function removeTestElement(element) {
    element.remove();
}
export function waitForComponent(elementName) {
    return window.customElements.whenDefined(elementName);
}
export function getComponentSlotContent(component) {
    return Array.from(component.shadowRoot.querySelectorAll('slot')).reduce((acc, slot) => {
        const name = slot.name.length > 0 ? slot.name : 'default';
        acc[name] = slot.assignedNodes().reduce((p, n) => {
            let returnDom = n.outerHTML;
            returnDom = n.outerHTML ? n.outerHTML : n.textContent.trim();
            return p + (returnDom ? returnDom : '');
        }, '');
        return acc;
    }, {});
}
function retry(fn, maxTries = 10, promise, promiseObject) {
    maxTries--;
    promiseObject = promiseObject || {
        resolve: null,
        reject: null,
    };
    promise =
        promise ||
            new Promise((resolve, reject) => {
                promiseObject.resolve = resolve;
                promiseObject.reject = reject;
            });
    fn()
        .then((result) => {
        promiseObject.resolve(result);
    })
        .catch(() => {
        if (maxTries > 0) {
            retry(fn, maxTries, promise, promiseObject);
        }
        else {
            promiseObject.reject('Max attempts reached');
        }
    });
    return promise;
}
export function componentIsStable(component) {
    return retry(() => 
    // eslint-disable-next-line no-async-promise-executor
    new Promise(async (resolve, reject) => {
        const stable = await component.updateComplete;
        if (stable) {
            resolve('success');
        }
        else {
            reject('error');
        }
    }));
}
//# sourceMappingURL=utils.js.map