/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import includes from 'ramda/es/includes';
import without from 'ramda/es/without';
export function getElementWidth(element, unit = 'px') {
    if (element) {
        return element.getBoundingClientRect ? element.getBoundingClientRect().width + unit : '';
    }
    return '';
}
export function getElementWidthUnless(element, unless) {
    if (!unless) {
        return getElementWidth(element);
    }
    return '';
}
export function isHTMLElement(el) {
    return !!el && el instanceof HTMLElement;
}
export function setAttributes(element, ...attributeTuples) {
    if (element) {
        attributeTuples.forEach(([attr, val]) => {
            if (val === false || val === null) {
                element.removeAttribute(attr);
            }
            else {
                element.setAttribute(attr, val + '');
            }
        });
    }
}
export function removeAttributes(element, ...attrs) {
    if (element) {
        attrs.forEach(attr => {
            element.removeAttribute(attr);
        });
    }
}
export function addAttributeValue(element, attr, value) {
    if (element) {
        const currentAttrVal = element.getAttribute(attr);
        if (!currentAttrVal) {
            element.setAttribute(attr, value);
        }
        else if (!includes(value, currentAttrVal.split(' '))) {
            // add it only if it is not already there
            element.setAttribute(attr, currentAttrVal + ' ' + value);
        }
    }
}
export function removeAttributeValue(element, attr, value) {
    if (element) {
        const currentAttrVal = element.getAttribute(attr);
        if (currentAttrVal) {
            // remove the specified value from the list of values currently set
            const attrValues = without([value], currentAttrVal.split(' '));
            const newAttrValue = attrValues.join(' ');
            if (newAttrValue) {
                element.setAttribute(attr, newAttrValue);
            }
            else {
                element.removeAttribute(attr);
            }
        }
    }
}
export function assignSlotNames(...slotTuples) {
    slotTuples.forEach(slotTuple => {
        const [el, slotName] = slotTuple;
        if (el) {
            setAttributes(el, ['slot', slotName]);
        }
    });
}
export function listenForAttributeChange(element, attrName, fn) {
    const observer = new MutationObserver(mutations => {
        if (mutations.find(m => m.attributeName === attrName)) {
            fn(element.getAttribute(attrName));
        }
    });
    observer.observe(element, { attributes: true });
    return observer;
}
export function isVisible(element) {
    return (element === null || element === void 0 ? void 0 : element.offsetHeight) > 0 && (element === null || element === void 0 ? void 0 : element.hasAttribute('hidden')) === false;
}
//# sourceMappingURL=dom.js.map