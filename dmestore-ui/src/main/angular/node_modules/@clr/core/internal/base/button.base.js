/*
 * Copyright (c) 2016-2020 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate } from "tslib";
import { html, LitElement, query } from 'lit-element';
import { ifDefined } from 'lit-html/directives/if-defined';
import { property, internalProperty } from '../decorators/property.js';
import { querySlot } from '../decorators/query-slot.js';
import { onAnyKey } from '../utils/keycodes.js';
import { stopEvent } from './../utils/events.js';
// TODO: replace with circular progress bar when complete
export const iconSpinnerCheck = html `<span class="button-status-icon" cds-layout="horizontal align:center"
  ><span class="spinner spinner-inline spinner-check" cds-layout="align:center"></span
></span>`;
export const iconSpinner = html `<span class="button-status-icon" cds-layout="horizontal align:center"
  ><span class="spinner spinner-inline" cds-layout="align:center"></span
></span>`;
export const iconSlot = html `<span class="button-icon"><slot name="button-icon"></slot></span>`;
export const badgeSlot = html `<span class="button-badge"><slot name="button-badge"></slot></span>`;
// @dynamic
export class CdsBaseButton extends LitElement {
    constructor() {
        super(...arguments);
        this.readonly = false;
        this.disabled = false;
        this.focused = false;
        this.role = 'button';
        /** @deprecated slotted anchor deprecated in 4.0 in favor of wrapping element */
        this.containsAnchor = false;
        this.isAnchor = false;
    }
    get hiddenButtonTemplate() {
        return this.readonly
            ? html ``
            : html `<button
          aria-hidden="true"
          ?disabled="${this.disabled}"
          tabindex="-1"
          style="display: none"
          value="${ifDefined(this.value)}"
          name="${ifDefined(this.name)}"
          type="${ifDefined(this.type)}"
        ></button>`;
    }
    render() {
        return html `
      <slot></slot>
      ${this.hiddenButtonTemplate}
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        this.tabIndex = 0; // initialize immediately so button can be focused synchronously
    }
    firstUpdated(props) {
        super.firstUpdated(props);
        this.setupAnchorFocus();
        this.setupNativeButtonBehavior();
    }
    updated(props) {
        super.updated(props);
        this.updateButtonAttributes();
    }
    setupAnchorFocus() {
        if (this.anchor) {
            this.anchor.addEventListener('focusin', () => (this.focused = true));
            this.anchor.addEventListener('focusout', () => (this.focused = false));
        }
    }
    /**
     * We have to append a hidden button outside the web component in the light DOM
     * This allows us to trigger native submit events within a form element.
     */
    setupNativeButtonBehavior() {
        this.appendHiddenButton();
        this.addEventListener('click', this.triggerNativeButtonBehavior);
        this.addEventListener('keydown', this.emulateKeyBoardEventBehavior);
    }
    triggerNativeButtonBehavior(event) {
        if (!this.readonly) {
            if (this.disabled) {
                stopEvent(event);
            }
            else if (event.target === this && !event.defaultPrevented) {
                this.hiddenButton.dispatchEvent(new MouseEvent('click', { relatedTarget: this, composed: true }));
            }
        }
    }
    appendHiddenButton() {
        if (!this.hiddenButton && this.templateButton) {
            this.hiddenButton = this.appendChild(this.templateButton);
        }
    }
    emulateKeyBoardEventBehavior(evt) {
        if (this.anchor) {
            return;
        }
        onAnyKey(['enter', 'space'], evt, () => {
            this.click();
            stopEvent(evt);
        });
    }
    updateButtonAttributes() {
        var _a;
        this.containsAnchor = !!this.anchor;
        this.isAnchor = ((_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) === 'A';
        if (this.isAnchor && this.parentElement) {
            this.parentElement.style.lineHeight = '0';
            this.parentElement.style.textDecoration = 'none'; // fixes issue when style is applied to text node
        }
        this.readonly = this.readonly || this.containsAnchor || this.isAnchor;
        this.role = this.readonly ? null : 'button';
        if (this.readonly) {
            this.tabIndexAttr = null;
        }
        else {
            this.tabIndexAttr = this.disabled ? -1 : 0;
        }
    }
}
__decorate([
    property({ type: Boolean })
], CdsBaseButton.prototype, "readonly", void 0);
__decorate([
    property({ type: String })
], CdsBaseButton.prototype, "type", void 0);
__decorate([
    property({ type: String })
], CdsBaseButton.prototype, "name", void 0);
__decorate([
    property({ type: String })
], CdsBaseButton.prototype, "value", void 0);
__decorate([
    property({ type: Boolean })
], CdsBaseButton.prototype, "disabled", void 0);
__decorate([
    internalProperty({ type: Number, attribute: 'tabindex', reflect: true })
], CdsBaseButton.prototype, "tabIndexAttr", void 0);
__decorate([
    internalProperty({ type: Boolean, reflect: true })
], CdsBaseButton.prototype, "focused", void 0);
__decorate([
    internalProperty({ type: String, reflect: true })
], CdsBaseButton.prototype, "role", void 0);
__decorate([
    internalProperty({ type: Boolean, reflect: true })
], CdsBaseButton.prototype, "containsAnchor", void 0);
__decorate([
    querySlot('a')
], CdsBaseButton.prototype, "anchor", void 0);
__decorate([
    internalProperty({ type: Boolean, reflect: true })
], CdsBaseButton.prototype, "isAnchor", void 0);
__decorate([
    querySlot('cds-icon')
], CdsBaseButton.prototype, "icon", void 0);
__decorate([
    querySlot('cds-badge')
], CdsBaseButton.prototype, "badge", void 0);
__decorate([
    query('button')
], CdsBaseButton.prototype, "templateButton", void 0);
//# sourceMappingURL=button.base.js.map