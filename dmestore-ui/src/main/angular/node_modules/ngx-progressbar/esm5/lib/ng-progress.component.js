import { __decorate } from "tslib";
import { Component, Input, Output, ChangeDetectionStrategy, EventEmitter } from '@angular/core';
import { Subscription } from 'rxjs';
import { map } from 'rxjs/operators';
import { NgProgress } from './ng-progress.service';
import { NgProgressRef } from './ng-progress-ref';
var NgProgressComponent = /** @class */ (function () {
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /** Creates a new instance if id is not already exists */
        this.id = 'root';
        /** Initializes inputs from the global config */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        get: function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    NgProgressComponent.prototype.ngOnChanges = function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    };
    NgProgressComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map(function (state) { return ({
            active: state.active,
            transform: "translate3d(" + state.value + "%,0,0)"
        }); }));
        // Subscribes to started and completed events on demand
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
        }
    };
    NgProgressComponent.prototype.ngOnDestroy = function () {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        if (this.progressRef instanceof NgProgressRef) {
            this.progressRef.destroy();
        }
    };
    NgProgressComponent.prototype.start = function () {
        this.progressRef.start();
    };
    NgProgressComponent.prototype.complete = function () {
        this.progressRef.complete();
    };
    NgProgressComponent.prototype.inc = function (n) {
        this.progressRef.inc(n);
    };
    NgProgressComponent.prototype.set = function (n) {
        this.progressRef.set(n);
    };
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress }
    ]; };
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "id", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "min", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "max", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "ease", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "color", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "speed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "thick", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "fixed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "meteor", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "spinner", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "trickleSpeed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "debounceTime", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "trickleFunc", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "spinnerPosition", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "direction", void 0);
    __decorate([
        Output()
    ], NgProgressComponent.prototype, "started", void 0);
    __decorate([
        Output()
    ], NgProgressComponent.prototype, "completed", void 0);
    NgProgressComponent = __decorate([
        Component({
            selector: 'ng-progress',
            host: {
                'role': 'progressbar',
                '[attr.spinnerPosition]': 'spinnerPosition',
                '[attr.dir]': 'direction',
                '[attr.thick]': 'thick',
                '[attr.fixed]': 'fixed'
            },
            template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [attr.active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{transform:rotate(3deg)}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{transform:rotate(4deg)}:host[dir=\"ltr+\"] .ng-bar,:host[dir=\"rtl+\"] .ng-bar{margin-left:-100%}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=\"rtl+\"] .ng-meteor{right:0}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{top:-3px}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{top:-4px}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{bottom:-3px}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}:host[dir=\"rtl+\"] .ng-bar-placeholder,:host[dir=ltr-] .ng-bar-placeholder{transform:rotate(180deg)}:host[dir=\"rtl+\"] .ng-spinner-icon,:host[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{transform:rotate(-3deg)}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar[active=true]{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes spinner-animation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}"]
        })
    ], NgProgressComponent);
    return NgProgressComponent;
}());
export { NgProgressComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXByb2dyZXNzYmFyLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUlOLHVCQUF1QixFQUN2QixZQUFZLEVBRWIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFjLFlBQVksRUFBbUIsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFxQ2xEO0lBb0NFLDZCQUFvQixXQUF1QjtRQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQWxDbkMsYUFBUSxHQUFxQixZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ2hELGVBQVUsR0FBcUIsWUFBWSxDQUFDLEtBQUssQ0FBQztRQVExRCx5REFBeUQ7UUFDaEQsT0FBRSxHQUFHLE1BQU0sQ0FBQztRQUVyQixnREFBZ0Q7UUFDdkMsUUFBRyxHQUFXLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztRQUMxQyxRQUFHLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQzFDLFNBQUksR0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDNUMsVUFBSyxHQUFXLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUM5QyxVQUFLLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQzlDLFVBQUssR0FBWSxJQUFJLENBQUMsV0FBVyxDQUFD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QUM1QztRQUFSLEtBQUssRUFBRTtzREFBK0M7SUFDOUM7UUFBUixLQUFLLEVBQUU7c0RBQStDO0lBQzlDO1FBQVIsS0FBSyxFQUFFO3NEQUFnRDtJQUMvQztRQUFSLEtBQUssRUFBRTtzREFBZ0Q7SUFDL0M7UUFBUixLQUFLLEVBQUU7dURBQWtEO0lBQ2pEO1FBQVIsS0FBSyxFQUFFO3dEQUFvRDtJQUNuRDtRQUFSLEtBQUssRUFBRTs2REFBNkQ7SUFDNUQ7UUFBUixLQUFLLEVBQUU7NkRBQTZEO0lBQzVEO1FBQVIsS0FBSyxFQUFFOzREQUEwRTtJQUN6RTtRQUFSLEtBQUssRUFBRTtnRUFBNkU7SUFDNUU7UUFBUixLQUFLLEVBQUU7MERBQWtGO0lBQ2hGO1FBQVQsTUFBTSxFQUFFO3dEQUE4QjtJQUM3QjtRQUFULE1BQU0sRUFBRTswREFBZ0M7SUE5QjlCLG1CQUFtQjtRQWxDL0IsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGFBQWE7WUFDdkIsSUFBSSxFQUFFO2dCQUNKLE1BQU0sRUFBRSxhQUFhO2dCQUNyQix3QkFBd0IsRUFBRSxpQkFBaUI7Z0JBQzNDLFlBQVksRUFBRSxXQUFXO2dCQUN6QixjQUFjLEVBQUUsT0FBTztnQkFDdkIsY0FBYyxFQUFFLE9BQU87YUFDeEI7WUFDRCxRQUFRLEVBQUUsNDRCQW9CVDtZQUVELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOztTQUNoRCxDQUFDO09BRVcsbUJBQW1CLENBdUcvQjtJQUFELDBCQUFDO0NBQUEsQUF2R0QsSUF1R0M7U0F2R1ksbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgRXZlbnRFbWl0dGVyLFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgU3Vic2NyaXB0aW9uTGlrZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOZ1Byb2dyZXNzIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5zZXJ2aWNlJztcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSZWYgfSBmcm9tICcuL25nLXByb2dyZXNzLXJlZic7XG5pbXBvcnQgeyBOZ1Byb2dyZXNzU3RhdGUgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nLXByb2dyZXNzJyxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAnW2F0dHIuc3Bpbm5lclBvc2l0aW9uXSc6ICdzcGlubmVyUG9zaXRpb24nLFxuICAgICdbYXR0ci5kaXJdJzogJ2RpcmVjdGlvbicsXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaycsXG4gICAgJ1thdHRyLmZpeGVkXSc6ICdmaXhlZCdcbiAgfSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic3RhdGUkIHwgYXN5bmM7IGxldCBzdGF0ZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm5nLXByb2dyZXNzLWJhclwiXG4gICAgICAgICAgICBbYXR0ci5hY3RpdmVdPVwic3RhdGUuYWN0aXZlXCJcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cIidvcGFjaXR5ICcgKyBzcGVlZCArICdtcyAnICsgZWFzZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmctYmFyLXBsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLWJhclwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zZm9ybV09XCJzdGF0ZS50cmFuc2Zvcm1cIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiY29sb3JcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cInN0YXRlLmFjdGl2ZSA/ICdhbGwgJyArIHNwZWVkICsgJ21zICcgKyBlYXNlIDogJ25vbmUnXCI+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwibWV0ZW9yXCIgY2xhc3M9XCJuZy1tZXRlb3JcIiBbc3R5bGUuYm94U2hhZG93XT1cIicwIDAgMTBweCAnKyBjb2xvciArICcsIDAgMCA1cHggJyArIGNvbG9yXCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0lmPVwic3Bpbm5lclwiIGNsYXNzPVwibmctc3Bpbm5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZy1zcGlubmVyLWljb25cIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJUb3BDb2xvcl09XCJjb2xvclwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJvcmRlckxlZnRDb2xvcl09XCJjb2xvclwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICBzdHlsZVVybHM6IFsnLi9uZy1wcm9ncmVzcy5jb21wb25lbnQuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcblxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3NDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zdGFydGVkOiBTdWJzY3JpcHRpb25MaWtlID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICBwcml2YXRlIF9jb21wbGV0ZWQ6IFN1YnNjcmlwdGlvbkxpa2UgPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIFByb2dyZXNzIGJhciB3b3JrZXIgKi9cbiAgcHJvZ3Jlc3NSZWY6IE5nUHJvZ3Jlc3NSZWY7XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHByb2dyZXNzIHN0YXRlICovXG4gIHN0YXRlJDogT2JzZXJ2YWJsZTx7IGFjdGl2ZTogYm9vbGVhbiwgdHJhbnNmb3JtOiBzdHJpbmcgfT47XG5cbiAgLyoqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgaWYgaWQgaXMgbm90IGFscmVhZHkgZXhpc3RzICovXG4gIEBJbnB1dCgpIGlkID0gJ3Jvb3QnO1xuXG4gIC8qKiBJbml0aWFsaXplcyBpbnB1dHMgZnJvbSB0aGUgZ2xvYmFsIGNvbmZpZyAqL1xuICBASW5wdXQoKSBtaW46IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1pbjtcbiAgQElucHV0KCkgbWF4OiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5tYXg7XG4gIEBJbnB1dCgpIGVhc2U6IHN0cmluZyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmVhc2U7XG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5jb2xvcjtcbiAgQElucHV0KCkgc3BlZWQ6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnNwZWVkO1xuICBASW5wdXQoKSB0aGljazogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRoaWNrO1xuICBASW5wdXQoKSBmaXhlZDogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmZpeGVkO1xuICBASW5wdXQoKSBtZXRlb3I6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5tZXRlb3I7XG4gIEBJbnB1dCgpIHNwaW5uZXI6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5zcGlubmVyO1xuICBASW5wdXQoKSB0cmlja2xlU3BlZWQ6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRyaWNrbGVTcGVlZDtcbiAgQElucHV0KCkgZGVib3VuY2VUaW1lOiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5kZWJvdW5jZVRpbWU7XG4gIEBJbnB1dCgpIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKSA9PiBudW1iZXIgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50cmlja2xlRnVuYztcbiAgQElucHV0KCkgc3Bpbm5lclBvc2l0aW9uOiAnbGVmdCcgfCAncmlnaHQnID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3Bpbm5lclBvc2l0aW9uO1xuICBASW5wdXQoKSBkaXJlY3Rpb246ICdsdHIrJyB8ICdsdHItJyB8ICdydGwrJyB8ICdydGwtJyA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRpcmVjdGlvbjtcbiAgQE91dHB1dCgpIHN0YXJ0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBjb21wbGV0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgZ2V0IGlzU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc1JlZi5pc1N0YXJ0ZWQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1Byb2dyZXNzOiBOZ1Byb2dyZXNzKSB7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5wcm9ncmVzc1JlZiBpbnN0YW5jZW9mIE5nUHJvZ3Jlc3NSZWYpIHtcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgY29uZmlnIHdoZW4gaW5wdXRzIGNoYW5nZVxuICAgICAgdGhpcy5wcm9ncmVzc1JlZi5zZXRDb25maWcoe1xuICAgICAgICBtYXg6ICh0aGlzLm1heCA+IDAgJiYgdGhpcy5tYXggPD0gMTAwKSA/IHRoaXMubWF4IDogMTAwLFxuICAgICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcbiAgICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXG4gICAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXG4gICAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxuICAgICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBHZXQgcHJvZ3Jlc3MgYmFyIHNlcnZpY2UgaW5zdGFuY2VcbiAgICB0aGlzLnByb2dyZXNzUmVmID0gdGhpcy5fbmdQcm9ncmVzcy5yZWYodGhpcy5pZCwge1xuICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICBzcGVlZDogdGhpcy5zcGVlZCxcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXG4gICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXG4gICAgfSk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJvZ3Jlc3Mgc3RhdGVcbiAgICB0aGlzLnN0YXRlJCA9IHRoaXMucHJvZ3Jlc3NSZWYuc3RhdGUucGlwZShcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcbiAgICAgICAgYWN0aXZlOiBzdGF0ZS5hY3RpdmUsXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3RhdGUudmFsdWV9JSwwLDApYFxuICAgICAgfSkpXG4gICAgKTtcblxuICAgIC8vIFN1YnNjcmliZXMgdG8gc3RhcnRlZCBhbmQgY29tcGxldGVkIGV2ZW50cyBvbiBkZW1hbmRcbiAgICBpZiAodGhpcy5zdGFydGVkLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0aGlzLnByb2dyZXNzUmVmLnN0YXJ0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RhcnRlZC5lbWl0KCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb21wbGV0ZWQub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY29tcGxldGVkID0gdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcGxldGVkLmVtaXQoKSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3RhcnRlZC51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX2NvbXBsZXRlZC51bnN1YnNjcmliZSgpO1xuICAgIGlmICh0aGlzLnByb2dyZXNzUmVmIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xuICAgICAgdGhpcy5wcm9ncmVzc1JlZi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zdGFydCgpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy5wcm9ncmVzc1JlZi5jb21wbGV0ZSgpO1xuICB9XG5cbiAgaW5jKG4/OiBudW1iZXIpIHtcbiAgICB0aGlzLnByb2dyZXNzUmVmLmluYyhuKTtcbiAgfVxuXG4gIHNldChuOiBudW1iZXIpIHtcbiAgICB0aGlzLnByb2dyZXNzUmVmLnNldChuKTtcbiAgfVxufVxuIl19