import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription, EMPTY } from 'rxjs';
import { tap, delay, debounce, switchMap, takeUntil, finalize, filter } from 'rxjs/operators';
export class NgProgressRef {
    constructor(customConfig, _onDestroyCallback) {
        this._onDestroyCallback = _onDestroyCallback;
        // Progress start source event (used to cancel finalizing delays)
        this._started = new Subject();
        // Progress start event: stream that emits only when it hasn't already started
        this.started = this._started.pipe(filter(() => !this.isStarted));
        // Progress ended source event
        this._completed = new Subject();
        // Progress start event: stream that emits only when it has already started
        this.completed = this._completed.pipe(filter(() => this.isStarted));
        // Stream that increments and updates the progress state
        this._trickling = new Subject();
        // Stream that combines "_trickling" and "config" streams
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(([start, config]) => timer(start ? config.debounceTime : 0)), switchMap(([start, config]) => start ? this.onTrickling(config) : this.onComplete(config))).subscribe();
    }
    // Get current progress state
    get currState() {
        return this._state.value;
    }
    // Check if progress has started
    get isStarted() {
        return this.currState.active;
    }
    /**
     * Start the progress
     */
    start() {
        this._started.next();
        this._trickling.next(true);
    }
    /**
     * Complete the progress
     */
    complete() {
        this._trickling.next(false);
    }
    /**
     * Increment the progress
     */
    inc(amount) {
        const n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    }
    /**
     * Set the progress
     */
    set(n) {
        this.setState({ value: this.clamp(n), active: true });
    }
    /**
     * Set config
     */
    setConfig(config) {
        this._config.next(Object.assign(Object.assign({}, this._config.value), config));
    }
    /**
     * Destroy progress reference
     */
    destroy() {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this._started.complete();
        this._completed.complete();
        this._onDestroyCallback();
    }
    /**
     * Set progress state
     */
    setState(state) {
        this._state.next(Object.assign(Object.assign({}, this.currState), state));
    }
    /**
     * Clamps a value to be between min and max
     */
    clamp(n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    }
    /**
     * Keeps incrementing the progress
     */
    onTrickling(config) {
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(() => this.inc()));
    }
    /**
     * Completes then resets the progress
     */
    onComplete(config) {
        this._completed.next();
        return !this.isStarted ? EMPTY : of({}).pipe(
        // Complete the progress
        tap(() => this.setState({ value: 100 })), 
        // Deactivate the progress after a tiny delay
        delay(config.speed * 1.7), tap(() => this.setState({ active: false })), 
        // Use a tiny delay before resetting
        delay(config.speed), 
        // Force the progress to reset even it got cancelled
        finalize(() => this.setState({ value: 0 })), 
        // Cancel any of the finalizing delays if the progress has started again
        takeUntil(this._started));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MtcmVmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXByb2dyZXNzYmFyLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLXJlZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWMsT0FBTyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNHLE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUc5RixNQUFNLE9BQU8sYUFBYTtJQW9DeEIsWUFBWSxZQUE4QixFQUFVLGtCQUE4QjtRQUE5Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQVk7UUExQmxGLGlFQUFpRTtRQUNoRCxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUMxQyw4RUFBOEU7UUFDckUsWUFBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRXJFLDhCQUE4QjtRQUNiLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzVDLDJFQUEyRTtRQUNsRSxjQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRXhFLHdEQUF3RDtRQUN2QyxlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUU1Qyx5REFBeUQ7UUFDeEMsWUFBTyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFhNUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGVBQWUsQ0FBa0IsRUFBRSxN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QkFBd0I7UUFDeEIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUV4Qyw2Q0FBNkM7UUFDN0MsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQ3pCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFM0Msb0NBQW9DO1FBQ3BDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ25CLG9EQUFvRDtRQUNwRCxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLHdFQUF3RTtRQUN4RSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUN6QixDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgQmVoYXZpb3JTdWJqZWN0LCB0aW1lciwgb2YsIGNvbWJpbmVMYXRlc3QsIFN1YnNjcmlwdGlvbiwgRU1QVFkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRhcCwgZGVsYXksIGRlYm91bmNlLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCwgZmluYWxpemUsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5nUHJvZ3Jlc3NTdGF0ZSwgTmdQcm9ncmVzc0NvbmZpZyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcblxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3NSZWYge1xuXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcHJvZ3Jlc3Mgc3RhdGUgaXMgY2hhbmdlZFxuICBwcml2YXRlIHJlYWRvbmx5IF9zdGF0ZTogQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NTdGF0ZT47XG4gIHN0YXRlOiBPYnNlcnZhYmxlPE5nUHJvZ3Jlc3NTdGF0ZT47XG5cbiAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBjb25maWcgaXMgY2hhbmdlZFxuICBwcml2YXRlIHJlYWRvbmx5IF9jb25maWc6IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPjtcbiAgY29uZmlnOiBPYnNlcnZhYmxlPE5nUHJvZ3Jlc3NTdGF0ZT47XG5cbiAgLy8gUHJvZ3Jlc3Mgc3RhcnQgc291cmNlIGV2ZW50ICh1c2VkIHRvIGNhbmNlbCBmaW5hbGl6aW5nIGRlbGF5cylcbiAgcHJpdmF0ZSByZWFkb25seSBfc3RhcnRlZCA9IG5ldyBTdWJqZWN0KCk7XG4gIC8vIFByb2dyZXNzIHN0YXJ0IGV2ZW50OiBzdHJlYW0gdGhhdCBlbWl0cyBvbmx5IHdoZW4gaXQgaGFzbid0IGFscmVhZHkgc3RhcnRlZFxuICByZWFkb25seSBzdGFydGVkID0gdGhpcy5fc3RhcnRlZC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5pc1N0YXJ0ZWQpKTtcblxuICAvLyBQcm9ncmVzcyBlbmRlZCBzb3VyY2UgZXZlbnRcbiAgcHJpdmF0ZSByZWFkb25seSBfY29tcGxldGVkID0gbmV3IFN1YmplY3QoKTtcbiAgLy8gUHJvZ3Jlc3Mgc3RhcnQgZXZlbnQ6IHN0cmVhbSB0aGF0IGVtaXRzIG9ubHkgd2hlbiBpdCBoYXMgYWxyZWFkeSBzdGFydGVkXG4gIHJlYWRvbmx5IGNvbXBsZXRlZCA9IHRoaXMuX2NvbXBsZXRlZC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmlzU3RhcnRlZCkpO1xuXG4gIC8vIFN0cmVhbSB0aGF0IGluY3JlbWVudHMgYW5kIHVwZGF0ZXMgdGhlIHByb2dyZXNzIHN0YXRlXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RyaWNrbGluZyA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgLy8gU3RyZWFtIHRoYXQgY29tYmluZXMgXCJfdHJpY2tsaW5nXCIgYW5kIFwiY29uZmlnXCIgc3RyZWFtc1xuICBwcml2YXRlIHJlYWRvbmx5IF93b3JrZXIgPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLy8gR2V0IGN1cnJlbnQgcHJvZ3Jlc3Mgc3RhdGVcbiAgcHJpdmF0ZSBnZXQgY3VyclN0YXRlKCk6IE5nUHJvZ3Jlc3NTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgcHJvZ3Jlc3MgaGFzIHN0YXJ0ZWRcbiAgZ2V0IGlzU3RhcnRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyU3RhdGUuYWN0aXZlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY3VzdG9tQ29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnLCBwcml2YXRlIF9vbkRlc3Ryb3lDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuX3N0YXRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHsgYWN0aXZlOiBmYWxzZSwgdmFsdWU6IDAgfSk7XG4gICAgdGhpcy5fY29uZmlnID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPihjdXN0b21Db25maWcpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9zdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX3N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuXG4gICAgdGhpcy5fd29ya2VyID0gY29tYmluZUxhdGVzdCh0aGlzLl90cmlja2xpbmcsIHRoaXMuX2NvbmZpZykucGlwZShcbiAgICAgIGRlYm91bmNlKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gdGltZXIoc3RhcnQgPyBjb25maWcuZGVib3VuY2VUaW1lIDogMCkpLFxuICAgICAgc3dpdGNoTWFwKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gc3RhcnQgPyB0aGlzLm9uVHJpY2tsaW5nKGNvbmZpZykgOiB0aGlzLm9uQ29tcGxldGUoY29uZmlnKSlcbiAgICApLnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBwcm9ncmVzc1xuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fc3RhcnRlZC5uZXh0KCk7XG4gICAgdGhpcy5fdHJpY2tsaW5nLm5leHQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIHByb2dyZXNzXG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dChmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBwcm9ncmVzc1xuICAgKi9cbiAgaW5jKGFtb3VudD86IG51bWJlcikge1xuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJTdGF0ZS52YWx1ZTtcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSB0aGlzLl9jb25maWcudmFsdWUudHJpY2tsZUZ1bmMobik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChuICsgYW1vdW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwcm9ncmVzc1xuICAgKi9cbiAgc2V0KG46IG51bWJlcikge1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZTogdGhpcy5jbGFtcChuKSwgYWN0aXZlOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb25maWdcbiAgICovXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcubmV4dCh7IC4uLnRoaXMuX2NvbmZpZy52YWx1ZSwgLi4uY29uZmlnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgcHJvZ3Jlc3MgcmVmZXJlbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3dvcmtlci51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuX3RyaWNrbGluZy5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX3N0YXRlLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fY29uZmlnLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fc3RhcnRlZC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX2NvbXBsZXRlZC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX29uRGVzdHJveUNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHByb2dyZXNzIHN0YXRlXG4gICAqL1xuICBwcml2YXRlIHNldFN0YXRlKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpIHtcbiAgICB0aGlzLl9zdGF0ZS5uZXh0KHsgLi4udGhpcy5jdXJyU3RhdGUsIC4uLnN0YXRlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICovXG4gIHByaXZhdGUgY2xhbXAobjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fY29uZmlnLnZhbHVlLm1pbiwgTWF0aC5taW4odGhpcy5fY29uZmlnLnZhbHVlLm1heCwgbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEtlZXBzIGluY3JlbWVudGluZyB0aGUgcHJvZ3Jlc3NcbiAgICovXG4gIHByaXZhdGUgb25Ucmlja2xpbmcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcudmFsdWUubWluKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVyKDAsIGNvbmZpZy50cmlja2xlU3BlZWQpLnBpcGUodGFwKCgpID0+IHRoaXMuaW5jKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgdGhlbiByZXNldHMgdGhlIHByb2dyZXNzXG4gICAqL1xuICBwcml2YXRlIG9uQ29tcGxldGUoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICB0aGlzLl9jb21wbGV0ZWQubmV4dCgpO1xuICAgIHJldHVybiAhdGhpcy5pc1N0YXJ0ZWQgPyBFTVBUWSA6IG9mKHt9KS5waXBlKFxuICAgICAgLy8gQ29tcGxldGUgdGhlIHByb2dyZXNzXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlOiAxMDAgfSkpLFxuXG4gICAgICAvLyBEZWFjdGl2YXRlIHRoZSBwcm9ncmVzcyBhZnRlciBhIHRpbnkgZGVsYXlcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCAqIDEuNyksXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogZmFsc2UgfSkpLFxuXG4gICAgICAvLyBVc2UgYSB0aW55IGRlbGF5IGJlZm9yZSByZXNldHRpbmdcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCksXG4gICAgICAvLyBGb3JjZSB0aGUgcHJvZ3Jlc3MgdG8gcmVzZXQgZXZlbiBpdCBnb3QgY2FuY2VsbGVkXG4gICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IDAgfSkpLFxuICAgICAgLy8gQ2FuY2VsIGFueSBvZiB0aGUgZmluYWxpemluZyBkZWxheXMgaWYgdGhlIHByb2dyZXNzIGhhcyBzdGFydGVkIGFnYWluXG4gICAgICB0YWtlVW50aWwodGhpcy5fc3RhcnRlZClcbiAgICApO1xuICB9XG59XG4iXX0=