import { __assign, __spread, __decorate, __param } from 'tslib';
import { InjectionToken, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, NgModule } from '@angular/core';
import { NavigationStart, NavigationEnd, NavigationCancel, NavigationError, Router } from '@angular/router';
import { of } from 'rxjs';
import { tap, delay, filter, switchMap } from 'rxjs/operators';
import { NgProgress } from 'ngx-progressbar';

var NG_PROGRESS_ROUTER_CONFIG = new InjectionToken('ngProgressRouterConfig');

/**
 * Check if a router event type exists in an array of router event types
 * @param routerEvent
 * @param events
 */
function eventExists(routerEvent, events) {
    var res = false;
    events.map(function (event) { return res = res || routerEvent instanceof event; });
    return res;
}
var NgProgressRouter = /** @class */ (function () {
    function NgProgressRouter(progress, router, config) {
        var _this = this;
        this._config = {
            id: 'root',
            delay: 0,
            startEvents: [NavigationStart],
            completeEvents: [NavigationEnd, NavigationCancel, NavigationError]
        };
        this._config = config ? __assign(__assign({}, this._config), config) : this._config;
        var progressRef = progress.ref(this._config.id);
        var startProgress = of({}).pipe(tap(function () { return progressRef.start(); }));
        var completeProgress = of({}).pipe(delay(this._config.delay), tap(function () { return progressRef.complete(); }));
        var filterEvents = __spread(this._config.startEvents, this._config.completeEvents);
        router.events.pipe(filter(function (event) { return eventExists(event, filterEvents); }), switchMap(function (event) { return eventExists(event, _this._config.startEvents) ? startProgress : completeProgress; })).subscribe();
    }
    NgProgressRouter.ctorParameters = function () { return [
        { type: NgProgress },
        { type: Router },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_ROUTER_CONFIG,] }] }
    ]; };
    NgProgressRouter.ɵprov = ɵɵdefineInjectable({ factory: function NgProgressRouter_Factory() { return new NgProgressRouter(ɵɵinject(NgProgress), ɵɵinject(Router), ɵɵinject(NG_PROGRESS_ROUTER_CONFIG, 8)); }, token: NgProgressRouter, providedIn: "root" });
    NgProgressRouter = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __param(2, Optional()), __param(2, Inject(NG_PROGRESS_ROUTER_CONFIG))
    ], NgProgressRouter);
    return NgProgressRouter;
}());

var NgProgressRouterModule = /** @class */ (function () {
    // Inject the service to activate it
    function NgProgressRouterModule(ngProgressRouter) {
    }
    NgProgressRouterModule_1 = NgProgressRouterModule;
    NgProgressRouterModule.withConfig = function (config) {
        return {
            ngModule: NgProgressRouterModule_1,
            providers: [
                { provide: NG_PROGRESS_ROUTER_CONFIG, useValue: config }
            ]
        };
    };
    var NgProgressRouterModule_1;
    NgProgressRouterModule.ctorParameters = function () { return [
        { type: NgProgressRouter }
    ]; };
    NgProgressRouterModule = NgProgressRouterModule_1 = __decorate([
        NgModule({})
    ], NgProgressRouterModule);
    return NgProgressRouterModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { NG_PROGRESS_ROUTER_CONFIG, NgProgressRouterModule, NgProgressRouter as ɵa };
//# sourceMappingURL=ngx-progressbar-router.js.map
